[{"title":"DRL","url":"/2023/02/27/DRL/","content":"路线数学+python及数据分析基础ML基础\n李航统计\n\n统计信息概论 感知机 K近邻 朴素贝叶斯 决策树 逻辑回归和最大熵 支持向量机 提升树 \nEM算法 隐马尔科夫 条件随机场 XGBoost\n\n\n\n刘建平：博客  GitHub \n\n\nML实战\n阿里云天池大赛 \n工业蒸汽预测 天猫用户重复购买预测 O2O优惠券预测 阿里云安全恶意程序检测\n七个步骤：赛题理解、数据探索、特征工程、模型训练、模型验证、特征优化、模型融合\n\nDL基础\n李沐（书+视频）\n\nPytorch框架\n\n邱锡鹏  \n\nNLP：CS224n \n\n课程 （1-5，8，9，11）\n\n作业  （1，2，4，5）\n\n要求：反向传播，词向量，RNN，GRU，Lstm，Seq2Seq以及attention机制 CNN\n\n\n\n\nDL实战\n新闻文本分类 \n\n赛题解析 \n\n分析数据 \n\n[基于ML的文本分类任务]：(https://tianchi.aliyun.com/notebook-ai/detail?spm=5176.12586969.1002.15.6406111aE3Lglg&amp;postId=118254 )\n\n不同深度学习模型\n\nfastext \nWord2vec \n\n\nCNN 做文本分类\nRNN做文本分类 \nBERT做文本分类 \n\n\n\n\n\nNote一 深度学习基础1.1 图灵书基础部分\n神经网络数学基础：数据表示：张量（tensor，多维Numpy数组）张量维度为轴，轴的个数为阶  标量 向量 矩阵 3+D张量\n评估模型注意事项：数据代表性–随机打乱  时间箭头–确保测试数据集时间晚于训练数据 数据冗余–确保训练集和验证集没有交集\n数据预处理：向量化、值标准化、处理缺失值  \n特征工程、过拟合和欠拟合：\n降低过拟合：more data / 减小网络容量 / 添加权重正则化 / 添加dropout\n\n\n\n1.2 PyTorch实践\n线性模型、梯度下降算法、反向传播\n\nCrossEntropy损失函数：softmax + NLLLoss\n\nimport torch\ny = torch.LongTensor([0])\nz = torch.Tensor([[0.2, 0.1, -0.1]])\ncriterion = torch.nn.CrossEntropyLoss()\nloss = criterion(z, y)\nprint(loss)\n+ `torch.squeeze(input, dim=None, *, out=None) → Tensor` 删除一个张量中所有维数为1的维度 dim指定维度 ；`torch.unsqueeze`指定位置扩充一个维度+ 测试集：  ```python  def test():      correct = 0      total = 0      with torch.no_grad():          for data in test_loader:              images， labels = data              outputs = model(images)              _, pred = torch.max(outputs.data, dim=1)              total = labels.size(0)              correct += (pred == labels).sum().item()      print('Accuracy on test: %d %%' % (100 * correct / total))\n\n\n\n\nDiabetes、Titanic、otto \n\nCNN\n\nRNN\n\n\nD2LC1 Intro\n数据集 由样本（数据点/实例）由特征（协变量）–&gt;标签/目标\nML问题\n监督学习：回归（squared error）、分类（cross-entropy）、标记、搜索、推荐系统、序列学习 \n无监督学习：聚类、主成分分析、因果关系和概率图模型、生成对抗性网络\n强化学习：\n状态完全可观察 markov decision process \n状态不依赖于之前的动作 contextual bandit problem \n无状态 只有最初一组未知回报的动作 multi-armed bandit problem\n\n\n\n\n\nC2 Basic\ntorch.cat((X, Y), dim=0/dim=1 )外层堆叠 / 内层拼接\n范数（Lp范数）\nL1：向量元素的绝对值之和\nL2：向量元素平方和的平方根\n\n\n\nC3 线性神经网络\n线性回归\n每个输入都与每个输出相连，这种变换称为全连接层（fully-connected layer）或称为稠密层（dense layer）\n\n\nsoftmax回归：输出非负且总和为1\n\nC4 多层感知机\n激活函数：ReLU、sigmoid、tanh\n\n模型选择、欠拟合和过拟合\n\n对抗过拟合称为正则化（regularization）\n训练误差、泛化误差\n\n\n权重衰减 (L2正则化)\n\nDropout\n\ndropout1, dropout2 = 0.2, 0.5\n\nnet = nn.Sequential(nn.Flatten(),\n        nn.Linear(784, 256),\n        nn.ReLU(),\n        # 在第一个全连接层之后添加一个dropout层\n        nn.Dropout(dropout1),\n        nn.Linear(256, 256),\n        nn.ReLU(),\n        # 在第二个全连接层之后添加一个dropout层\n        nn.Dropout(dropout2),\n        nn.Linear(256, 10))\n\ndef init_weights(m):\n    if type(m) == nn.Linear:\n        nn.init.normal_(m.weight, std=0.01)\n\nnet.apply(init_weights);\n+ Kaggle实战：预测房价  + 准备数据    + ```python      train_data = pd.read_csv(download('kaggle_house_train'))      test_data = pd.read_csv(download('kaggle_house_test'))\n\n\n预处理\n\n# 数值特征缩放到零均值和单位方差来标准化数据\nnumeric_features = all_features.dtypes[all_features.dtypes != 'object'].index\nall_features[numeric_features] = all_features[numeric_features].apply(\n    lambda x: (x - x.mean()) / (x.std()))\n# 缺失值设为0\n+ ```python  # “Dummy_na=True”将“na”（缺失值）视为有效的特征值，并为其创建指示符特征  all_features = pd.get_dummies(all_features, dummy_na=True)\n\n\ntrain_features test_features train_labels转换为张量\n\n训练\n\n建立模型\n损失函数取 预测对数与标签对数之间的均方根误差（ #在取对数时将小于1的值设置为1进一步稳定该值）\nAdam优化器对初始学习率不敏感\n\n\nk折交叉验证、模型选择\n\n\n\n\n\n\nC5 深度学习计算\n层和块\n自定义块、顺序块（Sequential类）\n\n\n参数管理\n参数访问、参数初始化、参数绑定\n\n\n延后初始化、自定义层\n读写文件\n加载和保存张量、加载和保存模型参数\n\n\nGPU\n\nC6 卷积神经网络\n从全连接层到卷积\n\n平移不变性、局部性\n\n\n图像卷积\n\n填充和步幅\n\n# padding para:高 宽 H*W\n# stride para:垂直 水平\nconv2d = nn.Conv2d(1, 1, kernel_size=(3, 5), padding=(0, 1), stride=(3, 4))\n+ 多输入多输出通道  + 用来扩展卷积层的模型  + 1x1卷积层（像素上，相当于全连接层）用于调整网络层的通道数量和模型复杂度+ 池化层  + 降低卷积层对位置的敏感性，降低对空间降采样表示的敏感性  + 最大或平均 通常在卷积层后 输出通道数与输入通道数相同  + ```python    X = torch.arange(16, dtype=torch.float32).reshape((1, 1, 4, 4))    pool2d = nn.MaxPool2d((2, 3), stride=(2, 3), padding=(0, 1))\n\n\n\n\n经典CNN：LeNet\n\n卷积激活池化 升维， MLP 降维，softmax输出\n\n\n现代CNN\n\n深度CNN（AlexNet）:基于LeNet 模型设计（卷积层 池化层 Dropout ReLU）\n\n\n使用块的网络VGG\n\n网络中的网络NiN\n\n含并行连结的网络GoogLeNet \n\n# 在通道维度上连结输出\n        return torch.cat((p1, p2, p3, p4), dim=1)\n\n\n\n\n批量归一化\n\n可学习的参数γ和β\n作用在\n全连接层和卷积层 输入上\n全连接层和卷积层输出上 激活函数前\n\n\n全连接层 作用在特征维\n卷积层 作用在通道维\n\n\n残差网络（ResNet）\n\n稠密连接网络（DenseNet）\n\n\nC7 循环神经网络\n序列模型\n自回归模型\n马尔可夫模型\n潜变量模型\n\n\n文本预处理\n语言模型和数据集 \nN元语法（t=N-1）\n读取长序列数据\n随机采样\n顺序分区\n\n\n\n\n循环神经网络\nGRU、LSTM、深层RNN、双向RNN、机器翻译与数据集、序列到序列学习、束搜索\n\n\n\nC8 注意力机制\n注意力分数\n注意力分数是query和key的相似度；注意力权重是分数的softmax结果\n常见分数计算：\n将query和key合并进入一个单隐藏层的MLP\n直接将query和key做内积\n\n\n\n\n使用注意力机制的seq2seq\n\n二 深度学习实践三 强化学习Easy RL（basis）C1 基础\n序列决策\n环境有自己的函数更新状态，智能体有自己的函数更新状态，智能体与环境状态等价时，即智能体能够观察到环境所有状态时，则称这个环境是完全可观测的，通常情况下，强化学习被建模成一个马尔可夫决策过程\n部分可观测马尔可夫决策过程(Partially Observable Markov Decision Processes, POMDP) 是一个马尔可夫决策过程的泛化\n\n\n动作空间\n强化学习智能体组成成分和类型\n组成成分\n策略：随机性策略 / 确定性策略\n价值函数\n模型：状态转移概率 + 奖励函数\n\n\n类型\n基于价值和策略智能体\n基于价值智能体\n基于策略智能体\n行动者-评论员智能体（actor-critic agent）\n\n\n有模型强化学习智能体：通过学习状态转移来采取动作；免模型强化学习智能体：通过学习价值函数和策略函数进行决策\n\n\n\n\n\nC2 马尔可夫决策过程\n马尔可夫过程\n马尔可夫性质：是指一个随机过程在给定现在状态及所有过去状态情况下，其未来状态的条件概率分布仅依赖于当前状态（将来的状态与过去状态是条件独立的）\n离散时间的马尔可夫过程也称为 马尔可夫链\n\n\n马尔可夫奖励过程：马尔可夫链 + 奖励函数\n回报与价值函数\n范围horizon：回合长度（每个回合最大时间步数）\n回报return：奖励的逐步叠加 \n状态价值函数\n\n\n贝尔曼方程\n\n\n\n\n\n马尔可夫决策过程\n马尔可夫决策过程中的策略、区别、价值函数、贝尔曼期望方程\n备份图、策略评估、预测和控制、动态规划、马尔可夫决策过程中的策略评估、马尔可夫决策过程控制、策略迭代、价值迭代、区别\n\n\n\nC3 表格型方法\n马尔可夫决策过程\n有模型\n免模型\n\n\nQ表格\n免模型预测\n蒙特卡洛策略评估：基于采样，使用经验平均回报\n时序差分 Temporal Difference（TD）：Q函数更新方式，使用下一步Q值更新当前Q值\n\n\n免模型控制\nSarsa 同策略（on-policy）时序差分控制\nQ学习 异策略（off-policy）时序差分控制\n区别\n\n\n\nWSS DRL（theory）C1 Basis\ntransition： 、、 、 \n激活函数\nlogistic回归 ReLU / 无\n二分类 sigmoid / tanh\n多分类 softmax\n\n\n动作随机、状态转移随机\n策略函数：\nReturn：$${ {\\rm{U} }t} = {R_t} + \\gamma {R{t + 1} } + {\\gamma ^2}{R_{t + 2} } + … = {R_t} + \\gamma { {\\rm{U} }_{t + 1} }$$ \nAction-value function： \nOptimal action-value function：\nState-value function：\n\nC2 价值学习\n使用nn近似 # in:s out:a para:w\n  预测 - TD target\nTemporal Difference（TD） Learning\n观测状态 动作\n预测 DQN计算\n求梯度\n环境提供新状态和奖励\n计算TD目标\n梯度下降\n降低w来减少loss: \n\n\n\n\n\nC3 策略学习\n策略函数： 概率密度函数（PDF）\n状态价值函数： \n用policy network 近似策略函数，近似价值函数 \n用policy gradient最大化θ\n计算策略梯度\n离散： =  for a in A\n连续： =  无偏估计/蒙特卡洛近似\n\n\n\n\nPolicy gradient algorithm\n观测状态\n根据policy network 随机采样\n计算\n求梯度\n近似策略梯度$$g({a_t},{\\theta t}) = {q_t} \\cdot {d{\\theta ,t}}$$\n更新策略网络\n\n\n近似作价值函数： \nREINFORCE: 遍历整个环境，使\nActor-Critic\n\n\n\nC4 Actor-Critic （策略-价值）\n状态价值函数： \nPolicy network（actor）：nn  近似  \nValue network（critic）：nn  近似 \n近似 \n\n\n训练网络：\n学习Policy network   增加状态价值；为此学习Value network  更好估计回报\n更新θ和w步骤\n观测状态\n根据policy network 随机采样\n环境提供新状态和奖励\n更新w （价值网络中用TD算法）\n更新θ （策略网络中用policy gradient算法）\n\n\nAlgorithm：\n观测状态 根据policy network 随机采样\n执行 环境提供新状态和奖励\n根据新状态随机采样 并不执行 \n计算价值网络 和 \n计算TD error $${\\delta t} = {q_t} - ({r_t} + \\gamma  \\cdot {q{t + 1}})$$ 预测和TD target之差\n价值网络求导  与w.shape相同\n更新价值网络$${w_{t + 1} } = {w_t} - \\alpha  \\cdot {\\delta t} \\cdot {d{w,t}}$$ \n策略网络求导 \n更新策略网络$${\\theta _{t + 1} } = {\\theta t} + \\beta  \\cdot {q_t} \\cdot {d{\\theta ,t}}$$ \nPolicy gradient with baseline $${\\theta _{t + 1} } = {\\theta _t} + \\beta  \\cdot {\\delta t} \\cdot {d{\\theta ,t}}$$\n\n\n\n\n\nC5 AlphaGoC6 Monte CarloC7 TD算法\nSarsa ( )\n\nQ_learning（）\n\n同策略（on-policy）异策略（off-policy）\n行为策略：控制智能体与环境交互的策略\n目标策略：强化学习的目标是得到一个策略来控制智能体\n异策略可使用经验回放\n\n\n\n\n\n","categories":["Note"],"tags":["OR","DRL"]},{"title":"DRL-PP","url":"/2023/09/19/DRLPP/","content":"Deep reinforcement learning based path planning and collision avoidance for smart ships in complex environmentsIntroductionBackground\nIntelligence in shipbuilding and shipping is a key trend enabling high-quality development in the post-pandemic era\nMain components\nAutonomous navigation\nAutomatic collision avoidance\nEnergy management systems\n\n\n\n\n\nSignificance\nIntelligent navigation is a vital smart ship technology realized through advanced automation and navigation systems\n\nSafety、efficiency、cost \noptimizing ship speeds and routes\nensuring navigation safety\nreducing fuel consumption and emissions\n\n\n\n\nTraditional methods\n\nhave limitations for path planning problems in random, complex environments which involve difficult-to-quantify factors like the environment and contingent uncertainties\nDeep reinforcement learning demonstrates better performance with abstract, difficult-to-quantify influences compared to traditional approaches\n\n\nWork basis\n\nGao P, Zhou L, Zhao X, Shao B, Research on ship collision avoidance path planning based on modified potential field ant colony algorithm [J]. Ocean and Coastal Management,2023,235(3): 106482. https://doi.org/10.1016/j.ocecoaman.2023.106482 .*\n\n\n\nProblem DescriptionShip collision avoidance problem description\nShip\nown ship\ntarget ship / mutli-ships\nobstacle (static、dynamic)\n\n\nCollision avoidance\nrules\nstate\naction\n\n\nPath planning\nobjective\nconstraints\nmethod\nAIS data\nrules\n\n\n\nShip domain modeling based on AIS and rules\nGrid Method\n\n\nEncounter Situation Classification\n\n\nLevel of ship collision risk\n\n\n\nModel and algorithmMarkov Decision Process\nState Space\n\n\nAction Space\n\n\nReward function\n\n\n\n\n\n\n\n\nTotal_reward\n\n\n\n\nReturn\n\n\n\nD3QN algorithm\nDueling Double DQN algorithm pseudocode\n\n\nto\n\n\nAdaptive decay greedy strategy\n\n\n\nSimulation ExperimentParameter setting\nShip information\n\n\n\n\nVessel\nName\nType\nSize (m)\nTonnage (t)\n\n\n\nOwn ship\nHang Xing817\nBulk cargo ship\n87-14.8-5.1\n2114\n\n\nTarget ship\nZhou Gong6006\nBulk cargo ship\n67.8-16.0-5.2\n2138\n\n\n\nHyperparameter\n\n\n\n\nHyperparameter\nValue\n\n\n\nEpisode\n3000\n\n\nLearning rate\n1-e4\n\n\nBatch size\n256\n\n\nTarget network update frequency\n3000\n\n\nReplay buffer\n100000\n\n\nSkit ratio\n0. 02\n\n\nPER\n0. 6\n\n\nPER\n0. 4\n\n\nWarm start\n50\n\n\nDiscount factor\n0.99\n\n\nCollision avoidance experiments\nHead-on\n\n\nCrossing\n\n\nOvertaking\n\n\nReward\n\n\n\nConclusion\nFor ship collision avoidance path planning in dynamic environments, large state and complex action spaces arise due to uncertainties.\nBased on AIS data and COLREGs, this paper designs rewards evaluating multiple rule-compliant behaviors. An adaptive attenuated greedy exploration strategy is introduced based on the prioritized experience replay D3QN algorithm. Experiments under various collision avoidance scenarios demonstrate that the proposed method achieves superior results.\nFurther considerations / extensions\nMulti-Obj / different reward\nComplexity： uncertainty、dynamic、multi-ships (communication)\n\n\n\n","categories":["Note"],"tags":["OR","DRL"]},{"title":"Hello World","url":"/2023/05/21/HelloWorld/","content":"WELCOME TO Lee’s Space!AID2L R2C Notion ChatGPT VisualAlgo GitHub Copilot Amazon CodeWhisperer CodeGeeX Cursor Runway Riffusion Midjourney Stable Diffusion Grammarly QuillBot WORLDSea !Cosmos !Game on line !Game on phone!My First Blog &amp; Website!","categories":["Personal"],"tags":["Hello"]},{"title":"Data Structure & Algorithm","url":"/2024/01/02/Data%20Structure%20&%20Algorithm%20in%20Java/","content":"💡 Java语言描述\nBinary Search 二分查找\nJava基本实现\npublic class BinarySearch{\t\tpublic BinarySearch() {    }\t\t// Basic\t\tpublic static int binarySearchBasic(int[] a, int target){        int i = 0, j = a.length - 1;        while (i &lt;= j){ //此处包含等号            int m = (i + j) &gt;&gt;&gt; 1; // 采用无符号右移代替/2得到均值取整            if (target &lt; a[m]) j = m - 1;\t\t\t\t\t\telse if (a[m] &lt; target) i = m + 1;            else return m;        }        return -1;    }\t\t// Balance\t\tpublic static int binarySearchBalance(int[] a, int target) {        int i = 0, j = a.length;        while (1 &lt; j - i) {            int m = (i + j) &gt;&gt;&gt; 1;            if (target &lt; a[m]) {                j = m;            } else {                i = m;            }        } //减少了循环内的平均比较次数        return (a[i] == target) ? i : -1;    }\t\t// Java inter\t\tprivate static int binarySearch0(long[] a, int fromIndex, int toIndex,                                     long key) {\t\t    int low = fromIndex;\t\t    int high = toIndex - 1;\t\t    while (low &lt;= high) {\t\t        int mid = (low + high) &gt;&gt;&gt; 1;\t\t        long midVal = a[mid];\t\t        if (midVal &lt; key)\t            low = mid + 1;\t\t        else if (midVal &gt; key)\t            high = mid - 1;\t\t        else            return mid; // key found\t\t    }\t\t    return -(low + 1);  // key not found; low为insertIndex\t\t}}\n\n时间复杂度\n\n按时间复杂度从低到高\n 常量时间 意味着算法时间并不随数据规模而变化\n 对数时间\n  线性时间 算法时间与数据规模成正比\n  拟线性时间\n 平方时间\nO  指数时间\n 阶乘时间\n\n\n渐进上界asymptotic upper bound：从某个常数开始， 总是位于)上方，那么记作,代表算法执行的最差情况\n渐进下界asymptotic lower bound：从某个常数开始， 总是位于)下方，那么记作,代表算法执行的最好情况\n渐进紧界asymptotic tight bound：从某个常数开始，总是位于$c_1g(n)和c_2g(n)之间，那么记作\\Theta(g(n))$\n二分查找\n时间复杂度：最坏：、最好\n空间复杂度：常数个指针,额外占用空间是\n\n\n\n\n**LeftRightmost**\n\n应用\n**\n\ncode\n\n求排名rank：leftmost(n)+1\n求前任predecessor：leftmost(n)-1\n求后任successor：rightmost(n)+1\n最近邻居\n\n\n范围查询\n\n —&gt; $0 .. leftmost(4) - 1$\n —&gt; $0 .. rightmost(4)$\n —&gt; $rightmost(4) + 1 .. \\\\infty$\n  —&gt; $leftmost(4) .. \\\\infty$\n —&gt; $leftmost(4) .. rightmost(7)$\n  —&gt; $rightmost(4)+1 .. leftmost(7)-1$\n\n\n\n\n\nArray 动态数组\n插入\npublic void add(int index,int element){    if (index &lt; 0 || index &gt; size) {        throw new ArrayIndexOutOfBoundsException();    }    else if (index &gt;=0 &amp;&amp; index &lt; size) {        System.arraycopy(array, index, array, index + 1, size - index); //索引插入    }    array[index] = element; //末端插入    size++;}\n\n遍历\n//forEach遍历public void foreach(Consumer&lt;Integer&gt; consumer){    for (int i = 0; i &lt; size; i++) {        consumer.accept(array[i]);    }}//测试public void test() {    DynamicArray dynamicArray = new DynamicArray();    dynamicArray.addLast(1);    dynamicArray.addLast(2);    dynamicArray.addLast(3);    dynamicArray.addLast(4);    /*\t\tResultCollector consumer = new ResultCollector();    dynamicArray.foreach(consumer);    consumer.test(List.of(1, 2, 3, 4));\t\t*/\t\tdynamicArray.foreach(e -&gt;{\t\t    System.out.println(e);    });}//迭代器遍历//Stream遍历\n\n删除\npublic int remove(int index){    int removed = array[index];    if (index &lt; 0 || index &gt;= size) {        throw new ArrayIndexOutOfBoundsException();    }    if (index&lt;size-1){        System.arraycopy(array, index + 1, array, index, size - index - 1);    }    size--;    return removed;}\n\n扩容\nprivate void checkAndGrow() {      if (size==0) {          array = new int[capacity];      }else if (size==capacity){          capacity += capacity &gt;&gt; 1;          int[] newArray = new int[capacity];          System.arraycopy(array,0,newArray,0,size);          array = newArray;      }  }\n\n局部性原理\n\n缓存的最小存储单位是缓存行cache line，一般是 64 bytes，最少读 64 bytes 填满一个缓存行，因此读入某个数据时也会读取其临近的数据，这就是所谓空间局部性\n\n\n\nLinked List 链表","categories":["Note"],"tags":["OR","Java","Algorithm"]},{"title":"OR-Writing Seminar","url":"/2023/10/25/OR-WritingSeminar/","content":"运筹优化论文写作Li Y. — IJOCNovel Formulations and Logic-Based Benders Decomposition for the Integrated Parallel Machine Scheduling and Location Problem\n摘要内容\n离散并行机器调度和位置问题，包括将多台机器定位到一组候选位置，将来自不同位置的作业分配给找到的机器，并对分配的作业进行排序。目标是最小化所有作业的最大完成时间，即完工时间。\n\n方法\n提出了三个新的混合整数线性模型，其性能优于最先进的公式。针对实际规模的实例开发了一种新的基于逻辑的 Benders 分解算法，该算法将问题分为确定机器位置和机器作业分配的主问题和对每台机器上的作业进行排序的子问题。主问题是通过在单个搜索树上运行的分支切割过程来解决的。一旦找到主问题的现有解决方案，就可以解决子问题以生成动态添加到主问题的Cuts。首先提出通用的切割，并通过一些强化技术对其改进。根据子问题的最优性条件开发了两种最优性切割，并通过强化技术进行了改进。\n\n选题与写作选题\n现实场景分析\n部署：Location\n分配：Assignment\n顺序：Scheduling\n目标：makespan\n\n\n联系文献\n分析问题特点\n工件分布在不同位置或区域\n机器位置分散且待选择\n\n\n定位理论问题：选址调度问题（Scheduling and Location Problem）\n实际问题与论文问题的联系，日常需要大量的文献积累\n\n\n调研文献\n识别出关键文献，经典的，最新的，需要精读\n文献综述的目的是掌握问题的研究进展，明确拟研究问题的研究意义\n\n\n重点文献梳理\n关键文献要深入读，反复读，明确其研究问题、贡献、模型、算法细节\n重点关注其提出的未来研究方向\n\n\n识别贡献\n对当前问题，文献尚未开展研究\n对当前问题，文献已有研究\n对同类或近似问题的研究不足以支持当前问题\n新问题（文献尚未开展研究）\n新模型（建模）\n新方法（算法设计）\n文献调研工作要充分，从相关文献开始，顺藤摸瓜，找到针对该问题的研究脉络。如：找到了重要文献A，要看A引用了哪些相关文献，以及哪些文献引用了A\n根据个人基础，选择合适的研究问题\n对于数学、计算机基础较好的同学，可尝试攻克经典问题\n两方面相对薄弱的同学，建议从问题创新角度出发，研究新问题然后遵循基本的新问题、新模型、新方法、新结果的研究思路\n生产-路径问题(Production-routing problem) (博士论文题目)\n\n\n\n\n初始题目\n导师给定: 食品供应链\n半年阅读文献，从综述开始看，然后看综述中比较前沿的研究问题，然后关注到供应商管理库存vender managed inventory（VMI）这样一种模式，以及这种模式背后的库存路径问题（Inventory routing problem)\n开始阅读IRP相关文献，并注意到了IRP问题并未涉及生产环节，每阶段可用的商品量是给定的参数，阅读到考虑生产的PRP文献，就是生产批量问题和IRP问题的结合\nPRP考虑食品特性的研究较少，如食品的易腐性，新鲜度等\n\n\n最终确定题目: 考虑食品质量的生产路径问题\n有想法后可多向老师汇报讨论，老师会根据经验进行判断，该主题是否值得做，未来做的题目的贡献点该如何体现\n\n\n\n写作与投稿写作\n基本原则\n\n写作以简洁、逻辑通顺为主\n句子之间、段落之间的衔接\n不同部分之间的联系，注意前后呼应\n完整、系统的将研究动机、研究现状、研究内容、研究结果、研究结论展示出来\n\n\nIntroduction\n\n五段式方法\n第一段：大背景，讲清楚研究问题在产业、行业、民生等方面的重要性\n第二段：新模式、新技术等带来的新特点，以及运营管理中面临的新问题\n第三段：新问题的研究进展，复杂特性、难点，亟待解决，现有文献无法有效覆盖\n第四段：本文要研究的内容，拟解决的问题，拟采用的方法，预计得到的结论\n第五段：整篇文章的安排\n\n\n\n\nLiterature review\n\n引出与本文研究问题最相关的研究问题有哪些，比如本文研究A,相关问题为BCD讲清楚BCD的研究进展，以及与A的关系\nA是如何拓展BCD的，BCD的研究缺乏对A的哪方面的考虑\nBCD的研究结果，如何无法直接适用到A，因为A的哪方面的特性\n最后，总结梳理A的新颖之处，如何拓展BCD，A的研究结果如何更好的解决BCD\n文献的展示方式有很多种，比如按照时间、按照主题、按照应用的方法等，对于一般OR论文，建议按照研究同一问题的方法划分，比如精确算法，启发式方法(不同类型的启发式)，并注意梳理不同文献之间的逻辑关系，比如B针对X问题提出了一个什么方法，获得了X结果；C在B的基础上，进一步拓展了xxx，提出了xxx方法，并将结果改进xxx；D采用了与B和C不同的方法，并获得了xxx结果。\n\n\nProblem description and formulation\n\n问题的设定，参数，以及限制，要描述清楚，假设要交代清楚\n模型的参数尽可能用a,b,c,d,e,f,g，下标用h,i,j,k，变量用x,y,z,u,v，集合用Q,K,J,V,N等\n尽量不用多个字母表示参数和变量\n模型的约束尽可能按照一定逻辑展示，比如分配的和路径相关的，一次性展示完\n模型的解释要一对一，详细解释\n模型之后，要给出问题的复杂度(部分需要证明)，且可做适当分析，提出一些有效不等式以加强模型\n\n\nSolution method\n\n问题的分析，结构特性，属于哪一类问题\n该类问题的常用解决方法，最有效解决方法\n不同方法对这类问题的适用性，说明选用方法的动机和原因\n总-分的方式，展示提出的方法，注意各部分之间的连接\n一定要严格按照程序实现的逻辑写，避免出现和程序不一致的情况\n\n\nComputational experiments\n\n先交代实验的目的，环境，配置，参数设置等\n数据的生成 （要有依据）和选取，算例的描述\n结果的呈现（要有逻辑，能看出趋势），按照一定的规则分开展示\n灵敏度分析，要分析参数对问题的影响、对算法的影响\n算法性能分析，对方法的设计是否有效，所声明的贡献是否真的是贡献\n结果是基础，好的结果，写起来相对容易但往往结果不一定全好，比如我们质量上差不多，但时间快，这时候我们要强调求解效率高；解质量高，但时间长，这时候我们要强调对于这类问题，我们算法所用时间是可接受的，且在可接受时间内大幅度改进了当前解。\n\n\nConclusion\n\n管理启示(Managerial implications)\n总结回顾本研究的问题、思路、方法、结果、结论\n重点讲结论，以及结论背后蕴含的管理意义\n指出文章研究的局限，以及未来可能研究的方向\n对未来研究，最好能给出一个脉络，比如从算法方面，可能可以从哪些方面进行突破\n全文几个地方要呼应，Introduction里面提出的问题，在文献综述部分，要强调现有研究无法支撑，文献综述识别的问题，在Introduction的研究内容中要明确指出。结论部分是文章的末尾，要明确说明本文是如何解决了Introduction中提出的问题的，如何弥补了文献综述中识别处的空白。\n\n\n\n投稿\n期刊选择\n首先自己评估论文的贡献，符合哪类期刊\n看引用的文献都发表在什么期刊\n选择同行认可度高的期刊\n其他因素: 学校列表、期刊投稿周期等\n语言的润色、查重\n不同期刊的写作风格可能不一样，需要根据期刊调整写作\n多征求合作者的意见，老师的意见，避免自己无目标的尝试，降低试错成本\n\n\n论文修改！！！\n认真对待审稿人的每一个问题\n尽量吸纳审稿人的意见，大部分情况下，审稿人提出的意见是具有一定的参考价值的\n对于一些算法的尝试，可以通过部分算例验证\n很多时候，审稿人没看懂，可能是我们没写清楚（逻辑清不清楚）\n审稿人提出的一些可能，要实验验证，并给出验证结果，正确则加入到正文，不正确或者无效，则在回复中说明\n\n\n\nJin B. — EJOR 金波SZU An exact algorithm for the unrestricted container relocation problem with new lower bounds and dominance rules\n摘要背景\n翻箱问题\n集装箱搬迁（翻箱）问题，也称为区块搬迁问题，是集装箱码头研究最多的优化问题之一。该问题旨在最小化根据特定顺序从堆场检索集装箱的搬迁总数。\nCRP background\n\n\n\n\n\n\n内容\n本研究的目的是开发一种高效的迭代深化分支定界算法，以准确解决该问题最实际的变体之一，即具有重复优先级的无限制集装箱搬迁问题。\n\n方法\n为了提高所提出算法的搜索效率，设计了两个新的下界，快速计算以将它们合并到分支定界算法中。提出了一组相互一致的支配规则以减少搜索空间，同时避免过度修剪。\n\n写作Abstract\nEJOR abstract\n\n\n\n\nIntroduction\nBackground\n概述研究关注的领域，引入研究的主题或问题\n根据研究问题是经典问题还是新问题，适当精简或详细背景介绍\n\n\nContainer relocation problem\n明确提出研究问题和假设\n方便审稿人和读者准确理解问题\n\n\nPurpose of this study\n研究目的、研究意义、理论重要性\n方便审稿人和读者快速了解本文的贡献和定位\n提供一个简要的概览，介绍论文的组织结构\n\n\n如何写好引言\n介绍研究背景，引出研究主题，引起读者兴趣\n明确定义问题，强调问题的重要性\n讨论现有工作，指出研究的必要性\n注意和文献综述的区别\n有的论文会直接把文献综述写在引言中\n\n\n明确研究目的，介绍所使用的研究方法\n强调研究的价值和贡献\n最后给出论文的组织结构\n\nLiterature review\nSearch-based exact methods\n\n本文算法属于该类，利用表格总结现有方法的研究空白，引出研究目的\n\n\nInteger programming approaches\n\n展现文献调研的全面性\n\n\nHeuristic approaches\n\n基于指标或规则的启发式方法（本文算法用到了其中的两个）\n基于元启发式框架的启发式方法\n\n\nRelated optimization problems\n\n展现文献调研的全面性\n\n\n如何写好文献综述\n\n明确定义研究领域，明确界定研究范围\n选择与研究直接相关的文献\n递归式收集文献，广泛阅读，精读关键文献\n\n\n对文献进行主题分类，制定清晰的综述结构\n寻找文献中的模式和趋势，帮助读者理解该领域的发展\n指出现有研究的缺陷或空白，论证研究的必要性\nS. Keshav: How to Read a Paper\n\n\nNotation and terminology\n\n符号和术语的定义有时会干扰正文的流畅性，将其放在一个单独的章节中可以减少这种干扰，使正文更加流畅。同时，该章节为读者提供了一个参考点，方便读者随时检索特定符号的含义。\n建议：尽可能使用简单易懂的符号系统，增加可读性。\n\n\n\nAlgorithm\nExact algorithm\nIterative deepening framework\n先介绍主框架\n\n\nDepth-limited search\n迭代算法每一轮所执行的深度受限搜索\n\n\nProbing heuristic\n混合使用两个不相上下的规则启发式方法（第三轮投稿新增）\n\n\n\n\nLower bounds\nExisting lower bounds\n回顾文献中的现有下界，发现模式和趋势\n\n\nMotivation for new lower bounds\n改进和创新\n\n\nLB-TS: lower bound by the tier scan method\n提出新下界（理论贡献）\n\n\nLB-PS: lower bound by the priority scan method\n提出新下界（理论贡献）\n\n\nInheritance of blocking layers\n介绍阻塞层的继承机制\n\n\n\n\nDominance rules\nLexicographic dominance principle\n提出字典序支配原则，并给出证明（理论贡献）\n\n\nMutually consistent dominance rules\n提出（整理和修订）13条相互兼容的支配规则\n每条支配规则的正确性证明放在附录\n\n\n\n\n\nComputational experiments\nExperimental settings：实验环境和测试数据集\nPreliminary comparison of lower bounds：初步比较所有下界，挑选后续实验的对照组\nComputational results for the benchmark datasets：主要实验结果\nEffect of the inheritance technique：对LB-TS有负面效果，对LB-PS有正面效果\nEffect of the hybrid probing strategy：混合探测策略比单独使用一个探测函数更好（第三轮投稿新增）\nEffect of the same-group relocation rules：箱子优先级多样性越低，效果越明显（第二轮投稿新增）\nComparison to metaheuristic approaches：在1秒的时间约束下，所提出的算法依然能够得到有竞争力的解（第二轮投稿新增）\n\nConclusion and future work\n回顾研究问题，总结主要发现，强调研究贡献\n指出研究局限性，展望未来研究方向\n\n如何提高学术论文写作水平\n深入了解领域知识，精确掌握领域术语\n广泛阅读和模仿，学习使用标准的学术写作风格\n仔细校对论文，确保语法、拼写和标点符号无误\n反复检查和修订论文，以提高语言流畅度和逻辑性\n寻求导师和合作者意见\n\nOR相关ModelJia S. — TRBThe seaport traffic scheduling problem: Formulations and a column-row generation algorithm\nAbstract背景\n海港交通拥堵可能导致泊位计划执行失控，船舶严重延误和等待时间过长。\n\n\n\n\n内容\n通过优化航道和码头港区锚地的利用来调度海港的船舶交通。将交通调度问题建模为MILP，将海港的物理布局和码头运营商设计的泊位计划作为输入，以最大限度地减少船舶的停泊和出发延误以及船舶数量无法顺利靠泊或离港。\n\n方法\n将 MILP 重新表述为更紧凑的集划分公式，开发了一种用于解决问题的列生成算法，并提出了三种性能增强策略，即行生成方法、定价问题减少方法和启发式定价方法，以加速列生成算法的收敛。\n\nFormulationOBJ\n最小化靠泊和离港迟到的总成本 以及未满足船舶服务请求的成本\n\nCons\n进出船舶在航道行驶的 安全间隙\n每艘船舶只能在某一潮汐窗口内通过航道、\n为船舶分配锚地\n确定船舶进出锚地的时间点\n每个分段锚地在单个时间点只能被一艘船占用\n\nModel\nORIG\n\n\n\n\nReformulated\n\n\n\n\nSolution\nSet-partitioning formulation\nColumn generation\nColumn-row generation\nReducing the pricing problems\nHeuristic pricing\nBranch-and-bound method\n\nJin B. — EJORAn exact algorithm for the unrestricted container relocation problem with new lower bounds and dominance rules\nGraph Model背景\n集装箱搬迁（翻箱）问题，也称为区块搬迁问题，是集装箱码头研究最多的优化问题之一。该问题旨在最小化根据特定顺序从堆场检索集装箱的搬迁总数。\n\n\n\n\n\nGraph M\n\n\nFormulation\n建模思路\n借鉴经典问题的建模思路\n混合整数规划MILP（非线性—&gt;线性）\n验证模型\n求解器（CPLEX GUROBI COPT）\n小规模算例（最优解对比算法性能）\n验证结果\n\n\n\n\n建模\n初始模型，检查是否存在错误，所有约束是否表达\n编程验证、软件求解、输出结果，检查\n根据结果反馈修改模型\n对于文献中的问题，可通过不同的建模方式改进原文献提出的模型，并进行对比实验，突出建模方面的贡献\n\n\n\nAlgorithm算法及实验问题求解精确算法\n求解器（Branch and cut）\nCPLEX\nGUROBI\nCOPT\n…\n\n\n分支定界（Branch and bound）\n分支切割（Branch and cut）\n列生成（Column generation）\n分支定价（Branch and price）\nBenders decompositon\nLogic-based Benders decomposition\n\n启发式算法\n传统基于规则或构造启发式方法\n局部搜索方法\n元启发式方法\nTS SA ALNS\n\n\n进化算法\nGA PSO AC\n\n\n基于数学的启发式方法\nRelax and fix\nFix and optimize\nKernel search\n\n\n\n算法选择\n合适算法\n问题本身研究进度，哪类方法最有效\n问题归类，相似问题的最有效方法\n问题本身，平衡，方法有效且能完成（理论分析和编程实现）\n\n\n不同方法的贡献点挖掘\n精确算法：框架适用，子问题的求解\n数学启发式：框架适用，基于模型的设计\n元启发式：初始解的设置，基于问题特点的算法设计\n\n\n选址调度问题的算法设计\n选址和调度决策，具有较好的分解性质\n在经典的并行机调度问题中，LBBD表现出不错的效果\n而选址一调度问题是经典并行机调度问题的拓展\n可能LBBD对求解选址-调度问题有效\n因此，拟选用该方法对提出问题进行求解\n\n\n贡献点挖掘\n框架的适用性（首次应用到所研究的问题）\n针对问题的特点，对框架的适用过程\n针对问题特点，对算法的独特设计（包含分解后子问题的求解）\n多个算法组合：要说明组合的必要性，如何互补提升效果；多层算法：讲清楚每层的贡献，多层之间的连接关系\n\n\n\n实验设计\n算例生成\n算例的选用\n经典问题（Benchmark）\n新问题（实际案例 + 随机算例 = new Benchmark）\n算例生成要充分参考文献，尊重现实数据\n算例数量适中\n对场景的覆盖程度\n小规模算例的必要性（验证、说明）\n\n\n结果展示\n定义核心指标（通用）\n单目标问题，通常：上界、下界、gap、时间等指标\n多目标问题，通常：帕累托解的数量、e-dominance\n现实案例：展示算法给出的解决方案对应的收益或成本优于企业当前解决方案\n图文并茂、图表结合\n\n\n结果分析\n对图表的解释，全面且有重点\n横向纵向比较\n基于图表，对规律进行总结、对异常进行解释\n关键参数的灵敏度分析\n算法性能分析实验（算法贡献点、实验结果支撑）\n\n\n\nAppendix\n飞书 Docs: https://pvkljwm7si8.feishu.cn/drive/folder/Wj03fCb8CllPkSdFRclcTV4an7e  Password: @1N61P/@\n参会反馈\n\n\n\n\n","categories":["Note"],"tags":["OR","Algorithm"]},{"title":"Operation Research","url":"/2024/01/01/Operation%20Research/","content":"OR👋 Welcome to OR!\nLP &amp; Simplex\nBasic concept\n约束方程系数矩阵，, \n当确定某一子矩阵为基矩阵时，基矩阵对应的列向量为基向量，其余列向量为非基向量\n基向量对应的变量为基变量，非基变量对应的变量为非基变量\n基变量、非基变量是针对某一确定 基 而言，不同 基 对应的基变量和非基变量也不同\n可行解：满足约束方程的解\n最优解：使目标函数达到最优值的解\n基本解：对于某一确定的基B，令非基变量为0，解出基变量，这组解称基B 的基本解\n基本可行解：基本解是可行解\n基本最优解：基本解是最优解\n基可行解对应的基：可行基；基本最优解对应的基：最优基\n凸集、凸组合、极点\n\n\nSimplex\nLP标准型\n目标函数最大值（最小值）、约束条件均为等式方程、变量、常数\n无约束，转化为\n+ 松弛变量 - 剩余变量\n\n\n单纯性表\n最大化问题，检验数小于等于0得到最优解\n多重最优解：存在非基变量检验数等于0\n无界解：某检验数大于0且对应向量小于等于0\n\n\n大M法、两阶段法\n大M\n约束条件引入人工变量，最大化问题目标函数\n\n\n两阶段\n第一阶段目标函数为最小化人工变量和，求得解\n基可行解作为初始可行解（单纯性表续），为原目标函数\n\n\n无可行解\n大M法：最优解中含有不为0的人工变量\n两阶段：第一阶段的最优值不为0\n\n\n\n\n退化与循环\n基本可行解中存在基变量为0，为退化基本可行解\n\n\n\n\n\nDual Problem\n对偶性质\n\n对称性：对偶问题的对偶是原问题\n\n最优性：为LP、DP的可行解，是最优解当且仅当\n\n弱对偶性：为\nLP、DP\n\n的可行解，则$CX\n≤Y\nb$\n\n对偶问题任意解的值为原问题目标值上界；原问题任意解的值为对偶问题目标值下界\n问题可行且具有无界解，则另一问题无可行解\n原问题可行，另一问题不可行，则原问题无界解\n\n\n对偶性：LP有最优解，则DP也有最优解，且最优值相等\n\nLP DP都有可行解，则都有最优解\n一个问题无最优解，另一问题也无最优解\n\n\n互补松驰性：为LP、DP的可行解，和是松弛变量的可行解，X* Y是最优解当且仅当$YsX=0$$、Y*Xs=0$\n\n\n检验数的相反数\n对应DP的一组基本解\n\n第j个决策变量检验数的相反数对应DP第j个松弛变量的解\n第i个松弛变量检验数的相反数对应DP第i个对偶变量的解\n\n检验数对应LP的一组基本解\n\n\n\n\n\n\n\nDijkstra\nDijkstra Algorithm\nBellman-Ford、Floyd algorithm\n\nBranch and BoundBranch and Cut\nBranch and bound + Cutting plane\n\nLagrangian RelaxationColumn GenerationBranch and priceDW decompositionBenders decomposition","categories":["Note"],"tags":["OR","Java","Algorithm"]},{"title":"Personal Resume","url":"/2023/05/22/Resume/","content":"基本信息\n姓       名：周立\n\n\n邮       箱：&#x7a;&#104;&#x6f;&#x75;&#x6c;&#105;&#x30;&#49;&#64;&#x73;&#116;&#117;&#46;&#115;&#99;&#x75;&#x2e;&#x65;&#100;&#117;&#x2e;&#99;&#110; \n\n\n2024.09-2028.06    四川大学            数据科学系        博士研究生\n\n\n2024.03-2028.06    华西生物医学大数据中心研究院    科研助理\n\n👋 Ni Hao!\n  \n\n\n👨‍🏫 ProfileMy name is Li Zhou (周立), and I am a Ph.D. student in the Department of Data Science at Sichuan University, Chengdu, China. I also work as a research assistant at the West China Hospital Biomedical Big Data Center.\nMy research interests include operations research and deep reinforcement learning, with applications in environmental management and biomedicine (AI4Environment &amp; AI4Biomedicine).\nIf you encounter any bugs or have questions, please feel free to reach out via email.\nSuggestions and collaborations are always welcome!\n研究工作、成果与经历成果\nLi Zhou, Liming Yao, Zerui Su*. (2025) A two-stage distributionally robust optimization framework for water quality management in uncertain reservoirs network. npj Clean Water (Incoming)\nZhou, L., Gao, P., &amp; Zhao, X. (2024, September). Deep Reinforcement Learning Based Path Planning and Collision Avoidance for Smart Ships in Complex Environments. In 2024 2nd International Conference on Signal Processing and Intelligent Computing (SPIC) (pp. 690-698). IEEE.\nGao, P., Zhou, L., Zhao, X., &amp; Shao, B. (2023). Research on ship collision avoidance path planning based on modified potential field ant colony algorithm. Ocean &amp; Coastal Management, 235, 106482.\n\n工作\nSubmissions\nAn adaptive large neighborhood search with dynamic exit reassignment for guided multi-story hospital fire evacuation\n\n\nWorking paper\nAI 4 Environment\nGlobal River Networks as Pollution Inequality Transmitters\n\n\nAI 4 Biomedicine\nEquity and efficiency-oriented routing and scheduling for home healthcare services with multiple hospital and communities\nTwo-Stage Robust Optimization Study on Emergency Medical Resource Scheduling Driven by Confidence Levels\nA value-based deep reinforcement learning framework with human expertise for anesthetics collaborative control\nContrastive Pretraining with Instrument Normalization for Metabolite Identification from Mass Spectra\n\n\n\n\n\n经历\nLogistics Research Network (LRN) Annual Conference China 2025\n\n中国“双法”研究会智能决策与博弈分会第三届学术年会\n\n2023年智能优化应用实践研讨会\n\n第三届运筹优化及人工智能学术研讨会\n\n2023数智决策与管理国际暑期学校（线上）–运筹学方向\n\nDatawhale AI夏令营（科大讯飞、阿里云天池）–NLP方向\n\n第十六届物流研究生暑期学校\n\n第三届“数据智能与管理”学术会议\n\n2023年智能优化论文写作研讨会\n\n\n基础技能\n英语水平：CET-6\n\n\n计算机语言：Java Python\n\n\n运筹优化常用模型、精确算法及Python+Java实现 \n智能优化算法 Algo、机器学习 ML、深度学习 DL、深度强化学习 DRL、大语言模型LLM\n\n性格兴趣\n性格类型：MBTI—ISFJ：友善、有责任心、严谨、务实 \n兴趣爱好：篮球、骑行、偶尔会羽毛球\n\n","categories":["Personal"],"tags":["Resume"]},{"title":"Java","url":"/2023/07/01/Java/","content":"💡 【  Learn Java！】\n\n\nJava程序基础基础概念\n整数运算\n\n自增/自减（++/- -）\nn++ 先引用n再加1\n++n先加1再引用n\n\n\n移位运算\n左移(n&lt;&lt;m)x2 右移(n&gt;&gt;m)/2\n无符号右移&gt;&gt;&gt;m\n强制类型转换(type)(精度丢失)\n\n\n\n\n布尔运算\n\n三元运算符：n ? x : y\n\n\n字符和字符串\n\n字符：char'' 基本数据类型\n字符串String\"\" 引用类型\n转义字符\n\\n 换行\n\\r 回车\n\\t Tab\n\n\n字符串拼接\n单行：+\n多行：'''…'''\n\n\n\n\n\n流程控制\n输入和输出\n\n格式化输出\n  public class Main {    public static void main(String[] args) {        double d = 3.1415926;        System.out.printf(\"%.2f\\n\", d); // 显示两位小数3.14        System.out.printf(\"%.4f\\n\", d); // 显示4位小数3.1416    }}\n\n占位符\n占位符对应传入参数，参数类型要和占位符一致\n%d 整数\n%f 浮点数\n%s 字符串\n%e 科学计数法\n%x 十六进制\n\n\n\n\n输入\n  import java.util.Scanner;public class Main {    public static void main(String[] args) {        Scanner scanner = new Scanner(System.in); // 创建Scanner对象        System.out.print(\"Input your name: \");        String name = scanner.nextLine(); // 读取一行输入并获取字符串        System.out.print(\"Input your age: \");        int age = scanner.nextInt(); // 读取一行输入并获取整数        System.out.printf(\"Hi, %s, you are %d\\n\", name, age); // 格式化输出    }}\n\n\n**if**\n\n浮点数判断相等：差值小于某个临界值\n引用类型判断相等：equals()\n如果s1为null,s1.equals(s2) 报错：NullPointerException\n采用&amp;&amp;判断 或将判断值作为对象调用equals()\n\n\n\n\n**switch**\n\nlambda的应用\n  public class Main {    public static void main(String[] args) {        String fruit = \"apple\";        int opt = switch (fruit) {            case \"apple\" -&gt; 1;            case \"pear\", \"mango\" -&gt; 2;            default -&gt; 0;        }; // 注意赋值语句要以;结束        System.out.println(\"opt = \" + opt);    }}\n\n用yield返回一个值作为switch语句的返回值\n\n\n\n\n数组操作面向对象面向对象基础\n方法\n\n可变参数\n\n可变参数用Type...定义，相当于数组类型\n\n示例\n  class Group {    private String[] names;    public void setNames(String... names) { //setNames(String[] names)        this.names = names;    }}//可变参数改写为String[]类型，需要先构造String[]\n\n\n参数绑定\n\n基本类型参数的传递：是调用方值的复制\n引用类型参数的传递，调用方的变量，和接收方的参数变量，指向的是同一个对象\n\n\n\n\n构造方法\n\n构造方法的名称是类名\n\n\n方法重载\n\n方法名相同，功能类似，参数不同，称为方法重载Overload 返回值类型通常相同\n\n\n继承\n\n**extends**关键字来实现继承\nprotected\n子类无法访问父类的private字段或者private方法\nprotected修饰的字段可以被子类访问（以及子类的子类）\n\n\n**super**\n子类不会继承任何父类的构造方法\n\n\n阻止继承\n用sealed修饰class，并通过permits明确写出能够从该class继承的子类名称\n\n\n向上转型upcasting\n子类类型安全地变为父类类型的赋值\n\n\n向下转型downcasting\ninstanceof判断一个变量所指向的实例是否是指定类型及其子类\n\n\n组合\n继承是is关系，组合是has关系\n\n\n\n\n多态\n\nPolymorphic ：实例方法调用是基于运行时的实际类型的动态调用，而非变量的声明类型\n如不同income的tax方法\n\n\n继承可以允许子类Override父类的方法\nfinal修饰的方法不能被覆写\nfinal修饰的类不能被继承\nfinal修饰的field在初始化后不能被修改\nfinal修饰局部变量不能被重新赋值\n\n\n\n\n抽象类\n\nabstract class 只能用于被继承，由子类实现其定义的抽象方法\n\n\n接口\n\n一个具体的class去实现一个interface时，需要使用implements关键字\n\n一个类不能从多个类继承，只能继承自另一个，但一个类可以实现多个interface\n\n继承关系\n\n接口比抽象类更抽象\n\n实例化的对象永远只能是某个具体的子类，但总是通过接口去引用它\n  List list = new ArrayList(); // 用List接口引用具体子类的实例Collection coll = list; // 向上转型为Collection接口Iterable it = coll; // 向上转型为Iterable接口\n\n\ndefault方法\n\n抽象类的普通方法可以访问实例字段\ninterface没有字段，default方法无法访问字段\n\n\n\n\n静态字段和静态方法\n\n静态字段\n静态字段为描述class本身的字段（非实例字段）\n所有实例共享一个静态字段\n推荐用类名来访问静态字段\n\n\n静态方法\n静态方法属于class而不属于实例\n用实例方法必须通过一个实例变量，而调用静态方法不需要实例变量，通过类名调用\n\n\n接口的静态字段\ninterface是一个纯抽象类，所以它不能定义实例字段\n\n可以有静态字段的，并且静态字段必须为final类型\n\ninterface的字段只能是public static final类型\n  public interface Person {    // 编译器会自动加上public statc final:    int MALE = 1;    int FEMALE = 2;}\n\n\n\n\n包\n\n如果有两个class名称相同，只能import其中一个，另一个必须写完整类名\n包名推荐使用倒置的域名\n\n\n作用域\n\n如果一个类内部还定义了嵌套类nested class，那么，嵌套类拥有访问private的权限\n包作用域：一个类允许访问同一个package\n没有public、private修饰的类\n没有public、protected、private修饰的字段和方法\n同一个包，可以访问package权限的class、field和method\n\n\n局部变量\n在方法内部定义的变量称为局部变量\n局部变量作用域从变量声明处开始到对应的块结束\n方法参数也是局部变量\n尽可能缩小局部变量的作用域，尽可能延后声明局部变量\n\n\npublic\n如果有public类，文件名必须和public类的名字相同\n一个.java文件只能包含一个public类，但可以包含多个非public类\n\n\n\n\n内部类\n\nInner Class的实例不能单独存在，必须依附于一个Outer Class的实例\n\nOuter.Inner inner = outer.**new** Inner();\n\n\nInner Class的作用域在Outer Class内部，所以能访问Outer Class的private字段和方法\n\n匿名类Anonymous Class\n\nasyncHello()方法，我们在方法内部实例化了一个Runnable\n\nRunnable本身是接口，接口是不能实例化的，所以这里实际上是定义了一个实现了Runnable接口的匿名类，并且通过new实例化该匿名类，然后转型为Runnable\n\nMain.java\n  public class Main {    public static void main(String[] args) {        Outer outer = new Outer(\"Nested\");        outer.asyncHello();    }}class Outer {    private String name;    Outer(String name) {        this.name = name;    }    void asyncHello() {        Runnable r = new Runnable() {            @Override            public void run() {                System.out.println(\"Hello, \" + Outer.this.name);            }        };        new Thread(r).start();    }}\n\n在定义匿名类的时候就必须实例化它，定义匿名类的写法如下\n  Runnable r =new Runnable() {// 实现必要的抽象方法...};\n\n匿名类也完全可以继承自普通类\n\nmap1是一个普通的HashMap实例\nmap2是一个匿名类实例，只是该匿名类继承自HashMap\nmap3也是一个继承自HashMap的匿名类实例，并且添加了static代码块初始化数据\n\n  public class Main {    public static void main(String[] args) {        HashMap&lt;String, String&gt; map1 = new HashMap&lt;&gt;();        HashMap&lt;String, String&gt; map2 = new HashMap&lt;&gt;() {}; // 匿名类!        HashMap&lt;String, String&gt; map3 = new HashMap&lt;&gt;() {            {                put(\"A\", \"1\");                put(\"B\", \"2\");            }        };        System.out.println(map3.get(\"A\"));    }}\n\n\n静态内部类Static Nested Class\n\n用static修饰的内部类和Inner Class有很大的不同，它不再依附于Outer的实例，而是一个完全独立的类\n因此无法引用Outer.this，但它可以访问Outer的private静态字段和静态方法\n如果把StaticNested移到Outer之外，就失去了访问private的权限\n\n\n\n\n\nJava核心类\n字符串和编码\n\nString\n\nString是一个引用类型，它本身也是一个class\n可以直接用\"...\"这种字符串字面量表示方法\n字符串不可变\n\n\n字符串比较\n\n使用equals()方法而不能用==\nString类还提供了多种方法来搜索子串、提取子串\n\n\n去除首尾空白字符\n\n使用trim()方法可以移除字符串首尾空白字符。空白字符包括空格，\\t，\\r，\\n\n\ntrim()并没有改变字符串的内容，而是返回了一个新字符串\n\n\nstrip()方法也可以移除字符串首尾空白字符\n\n和trim()不同的是，类似中文的空格字符\\u3000也会被移除\n\n\nString还提供了isEmpty()和isBlank()来判断字符串是否为空和空白字符串\n\n空和空白字符串\n  \"\".isEmpty(); // true，因为字符串长度为0\"  \".isEmpty(); // false，因为字符串长度不为0\"  \\n\".isBlank(); // true，因为只包含空白字符\" Hello \".isBlank(); // false，因为包含非空白字符\n\n\n\n\n替换字串\n\n根据字符或字符串替换\n正则表达式\n\n\n分割字符串\n\n使用split()方法，并且传入的也是正则表达式\n\n\n拼接字符串\n\n使用静态方法join()，它用指定的字符串连接字符串数组\n\n\n格式化字符串\n\nformatted()方法和format()静态方法，可以传入其他参数，替换占位符，然后生成新的字符串\n占位符\n\n\n类型转换\n\n任意基本类型或引用类型转换为字符串，使用静态方法valueOf() （重载方法）\n字符串转换为其他类型\n\n\n转换为char[]\n\nString和char[]类型可以互相转换\n\n示例\n  char[] cs = \"Hello\".toCharArray(); // String -&gt; char[]String s = new String(cs); // char[] -&gt; String\n\n如果修改了char[]数组，String并不会改变\n\n\n\n字符编码\n\n\n\n**StringBuilder**\n\n链式操作：类定义的append()方法会返回实例本身this\n\n\nStringJoiner\n\n用分隔符拼接数组\nString还提供了一个静态方法join()\n\n\n包装类型\n\n基本类型→引用类型 Auto Boxing + Auto unboxing\n所有的包装类型都是不变类\n实例的比较使用equals\n创建新对象时，优先选用静态工厂方法（Integer.valueOf()）而不是new操作符\n进制转换：静态方法parseInt()可以把字符串解析成一个整数\n整数和浮点数的包装类型都继承自Number\n\n\nJavaBean\n\n一种符合命名规范的class，它通过getter和setter来定义属性\n使用Introspector.getBeanInfo()可以获取属性列表\n\n\n枚举类\n\n使用enum定义枚举类型，编译器编译为final class Xxx extends Enum { … }\n通过name()获取常量定义的字符串，不使用toString()\n通过ordinal()返回常量定义的顺序\n可以为enum编写构造方法、字段和方法\nenum的构造方法要声明为private，字段声明为final\n\n\nenum适合用在switch语句中\n\n\n记录类\n\n和enum类似，不能从Record派生，只能通过record关键字由编译器实现继承\n\nrecord Point(**int** x, **int** y) {}\n\n把上述定义改写为class，相当于\n  final class Point extends Record {    private final int x;    private final int y;    public Point(int x, int y) {        this.x = x;        this.y = y;    }    public int x() {        return this.x;    }    public int y() {        return this.y;    }    public String toString() {        return String.format(\"Point[x=%s, y=%s]\", x, y);    }    public boolean equals(Object o) {        ...    }    public int hashCode() {        ...    }}/* 除了用final修饰class以及每个字段外   编译器还自动为我们创建了构造方法，和字段名同名的方法   以及覆写toString()、equals()和hashCode()方法*/\n\n\n构造方法\n\nPoint的构造方法加上检查逻辑\n  public record Point(int x, int y) {    public Point {        if (x &lt; 0 || y &lt; 0) {            throw new IllegalArgumentException();        }    }}\n\n方法public Point {...}被称为\n\n常见的静态方法of()，用来创建Point\n  public record Point(int x, int y) {    public static Point of() {        return new Point(0, 0);    }    public static Point of(int x, int y) {        return new Point(x, y);    }}var z = Point.of();var p = Point.of(123, 456);\n\n\n\n\nBigInteger\n\nBigInteger用于表示任意大小的整数；\nBigInteger是不变类，并且继承自Number；\n将BigInteger转换成基本类型时可使用longValueExact()等方法保证结果准确\n\n\nBigDecimal\n\nBigDecimal用于表示精确的小数，常用于财务计算；\n比较BigDecimal的值是否相等，必须使用compareTo()而不能使用equals()\n\n\n常用工具类\n  REF \n\nMath：数学计算\nRandom：生成伪随机数\nSecureRandom：生成安全的随机数\n\n\n\n异常处理\nJava的异常\n\n异常是一种class，本身带有类型信息\n异常可以在任何地方抛出，但只需要在上层捕获，这样就和方法调用分离了\nThrowable是异常体系的根，它继承自Object\nThrowable有两个体系:Error和Exception\nError表示严重的错误\nException则是运行时的错误，它可以被捕获并处理\n\n\n必须捕获的异常，包括Exception及其子类，但不包括RuntimeException及其子类，这种类型的异常称为Checked Exception。\n不需要捕获的异常，包括Error及其子类，RuntimeException及其子类\n捕获异常\n使用try...catch语句，把可能发生异常的代码放到try {...}中，然后使用catch捕获对应的Exception及其子类\n\n在方法定义的时候，使用throws Xxx表示该方法可能抛出的异常类型。调用方在调用的时候，必须强制捕获这些异常，否则编译器会报错\n\n只要是方法声明的Checked Exception，不在调用层捕获，也必须在更高的调用层捕获。所有未捕获的异常，最终也必须在main()方法中捕获\n  public class Main {    public static void main(String[] args) {        try {            byte[] bs = toGBK(\"中文\");            System.out.println(Arrays.toString(bs));        } catch (UnsupportedEncodingException e) {            System.out.println(e);        }    }    static byte[] toGBK(String s) throws UnsupportedEncodingException {        // 用指定编码转换String为byte[]:        return s.getBytes(\"GBK\");    }}\n\n\n\n\n捕获异常\n\n多catch语句\n\nfinally语句\n\n捕获多种异常\n  public static void main(String[] args) {    try {        process1();        process2();        process3();    } catch (IOException | NumberFormatException e) { // IOException或NumberFormatException        System.out.println(\"Bad input\");    } catch (Exception e) {        System.out.println(\"Unknown error\");    }}\n\n\n抛出异常\n\n异常的传播\n\n当某个方法抛出了异常时，如果当前方法没有捕获异常，异常就会被抛到上层调用方法，直到遇到某个try ... catch被捕获为止\n\n\n抛出异常\n\n创建某个Exception的实例\n\n用throw语句抛出\n\n示例\n  void process2(String s) {    if (s==null) {        throw new NullPointerException();    }}\n\n\n异常屏蔽（Suppressed Exception）\n\n先用origin变量保存原始异常，然后调用Throwable.addSuppressed()，把原始异常添加进来，最后在finally抛出\n\n\n\n\n自定义异常\n\n自定义一个BaseException，从RuntimeException派生\n\n自定义的BaseException应该提供多个构造方法\n  public class BaseException extends RuntimeException {    public BaseException() {        super();    }    public BaseException(String message, Throwable cause) {        super(message, cause);    }    public BaseException(String message) {        super(message);    }    public BaseException(Throwable cause) {        super(cause);    }}\n\n\n**NullPointerException**\n\n处理NullPointerException\n成员变量在定义时初始化\n  public class Person {    private String name = \"\";}\n\n返回空字符串\"\"、空数组而不是null\n\n返回Optional&lt;T&gt;\n\n\n\n定位NullPointerException\n\n\n**Assertion**\n\n单元测试与JUnit\n\n\n**Log**\n\nJDK Logging\n\n日志可以存档，便于追踪问题\n按级别分类\njava.util.logging来实现日志功能\n\n\nCommons Logging\n\n在静态方法中引用Log，定义一个静态类型变量\n  public class Main {    static final Log log = LogFactory.getLog(Main.class);    static void foo() {        log.info(\"foo\");    }}\n\n在实例方法中引用Log，定义一个实例变量\n  public class Person {    protected final Log log = LogFactory.getLog(getClass());    void foo() {        log.info(\"foo\");    }}\n\n实例变量log的获取方式是LogFactory.getLog(getClass())子类可以直接使用该log实例\n  public class Student extends Person {    void bar() {        log.info(\"bar\");    }}\n\n\nLog4j\n\nRef \nDownload \n\n\nSLF4J和Logback\n\nRef \n\n\n\n\n\n反射\n反射\n\n反射Reflection指程序在运行期可以拿到一个对象的所有信息\n\nClass类\n\nJVM为每个加载的class创建了对应的Class实例，并在实例中保存了该class的所有信息\n通过Class实例获取class信息的方法称为反射Reflection\n\n\n获取一个class的Class实例\n\n通过一个class的静态变量class\n  Class cls = String.class;\n\n一个实例变量，通过实例变量提供的getClass()方法\n  String s = \"Hello\";Class cls = s.getClass();\n\n通过 class的完整类名，静态方法Class.forName()\n  Class cls = Class.forName(\"java.lang.String\");\n\n\nClass实例比较和instanceof\n\ninstanceof不但匹配指定类型，还匹配指定类型的子类\n\n==判断class实例可以精确地判断数据类型，但不能作子类型比较\n\n通过反射获取该Object的class信息\n  void printObjectInfo(Object obj) {    Class cls = obj.getClass();}\n\n\n动态加载\n\n运行期根据条件来控制加载class\n\n\n\n\n访问字段\n\n通过Class实例获取所有Field对象\nField getField(name)：根据字段名获取某个public的field（包括父类）\nField getDeclaredField(name)：根据字段名获取当前类的某个field（不包括父类）\nField[] getFields()：获取所有public的field（包括父类）\nField[] getDeclaredFields()：获取当前类的所有field（不包括父类）\n\n\n首先获取Student的Class实例，然后，分别获取public字段、继承的public字段以及private字段\ngetName()：返回字段名称，例如，\"name\"\ngetType()：返回字段类型，也是一个Class实例，例如，String.class\ngetModifiers()：返回字段的修饰符，它是一个int，不同的bit表示不同的含义\n\n\n字段值\n获取字段值\n先获取Class实例，再获取Field实例，然后用Field.get(Object)获取指定实例的指定字段的值\n\n\n设置字段值\n通过Field.set(Object, Object)实现的，其中第一个Object参数是指定的实例，第二个Object参数是待修改的值\n修改非public字段，需要首先调用setAccessible(true)\n\n\n\n\n\n\n调用方法\n\n通过Class实例获取所有Method信息\nMethod getMethod(name, Class...)：获取某个public的Method（包括父类）\nMethod getDeclaredMethod(name, Class...)：获取当前类的某个Method（不包括父类）\nMethod[] getMethods()：获取所有public的Method（包括父类）\nMethod[] getDeclaredMethods()：获取当前类的所有Method（不包括父类）\n\n\n获取Student的Class实例，然后，分别获取public方法、继承的public方法以及private方法\ngetName()：返回方法名称，例如：\"getScore\"\ngetReturnType()：返回方法返回值类型，也是一个Class实例，例如：String.class\ngetParameterTypes()：返回方法的参数类型，是一个Class数组，例如：{String.class, int.class}\ngetModifiers()：返回方法的修饰符，它是一个int，不同的bit表示不同的含义\n\n\n调用方法\n对Method实例调用invoke就相当于调用该方法，invoke的第一个参数是对象实例，即在哪个实例上调用该方法，后面的可变参数要与方法参数一致\n\n\n调用静态方法\n如果获取到的Method表示一个静态方法，调用静态方法时，由于无需指定实例对象，所以invoke方法传入的第一个参数永远为null\n\n\n调用非public方法\n和Field类似，对于非public方法，可以通过Class.getDeclaredMethod()获取该方法实例\nMethod.setAccessible(true)允许其调用\n\n\n多态\n使用反射调用方法时，遵循多态原则：即总是调用实际类型的覆写方法（如果存在）\n\n\n\n\n调用构造方法\n\n通过Class实例获取Constructor的方法\ngetConstructor(Class...)：获取某个public的Constructor；\ngetDeclaredConstructor(Class...)：获取某个Constructor；\ngetConstructors()：获取所有public的Constructor；\ngetDeclaredConstructors()：获取所有Constructor。\n\n\nJava反射API提供了Constructor对象，包含一个构造方法所有信息，可以创建一个实例\nConstructor总是当前类定义的构造方法，和父类无关，因此不存在多态的问题\n调用非public的Constructor时，必须首先通过setAccessible(true)设置允许访问\n\n\n获取继承关系\n\n获取父类的Class\n\n有了Class实例，获取父类的Class\n  Class i = Integer.class;Class n = i.getSuperclass();\n\n\n获取interface\n\nClass[] getInterfaces()只返回当前类直接实现的接口类型，并不包括其父类实现的接口类型\n获取接口的父接口要用getInterfaces()\n\n\n继承关系\n\n判断一个实例是否是某个类型时，使用instanceof操作符\n两个Class实例，要判断一个向上转型是否成立，调用isAssignableFrom()\n\n\n\n\n动态代理\n\nDynamic Proxy：在运行期动态创建某个interface的实例\n定义一个InvocationHandler实例，它负责实现接口的方法调用\n通过Proxy.newProxyInstance()创建interface实例，它需要3个参数\n使用的ClassLoader，通常就是接口类的ClassLoader\n需要实现的接口数组，至少需要传入一个接口进去\n用来处理接口方法调用的InvocationHandler实例\n\n\n将返回的Object强制转型为接口\n\n\n\n\n\n注解\n使用注解\n\n注解Annotation是放在Java源码的类、方法、字段、参数前的一种特殊“注释”\n注释会被编译器忽略，注解被编译器打包进入class文件，是一种用作标注的“元数据”\n\n\n注解作用\n一、编译器使用的注解\n@Override：让编译器检查该方法是否正确地实现了覆写\n@SuppressWarnings：让编译器忽略此处代码产生的警告\n这类注解不会被编译进入.class文件\n\n\n二、工具处理.class文件使用的注解\n三、在程序运行期能够读取的注解，它们在加载后一直存在于JVM中\n定义一个注解时，还可以定义配置参数\n\n\n\n\n定义注解\n\n使用@interface语法来定义注解\n\n注解的参数类似无参数方法，default默认值。最常用的参数应当命名为value\n  public @interface Report {    int type() default 0;    String level() default \"info\";    String value() default \"\";}\n\n\n元注解\n\n元注解meta annotation可以修饰其他注解\n\n元注解@Target定义Annotation能够被应用于源码的哪些位置\n\n类或接口：ElementType.TYPE\n字段：ElementType.FIELD\n方法：ElementType.METHOD\n构造方法：ElementType.CONSTRUCTOR\n方法参数：ElementType.PARAMETER\n示例\n定义注解@Report用在方法上，必须添加\n\n@Target(ElementType.METHOD\n\n\n定义注解@Report可用在方法或字段上，可以把@Target注解参数变为数组\n  @Target({    ElementType.METHOD,    ElementType.FIELD})public @interface Report {    ...}\n\n\n\n\n元注解@Retention定义Annotation的生命周期\n\n仅编译期：RetentionPolicy.SOURCE\n仅class文件：RetentionPolicy.CLASS\n运行期：RetentionPolicy.RUNTIME\ndefault：@Retention(RetentionPolicy.RUNTIME)\n\n\n元注解@Repeatable定义Annotation是否可重复\n\n元注解@Inherited定义子类是否可继承父类定义的Annotation\n\n@Inherited仅针对@Target(ElementType.TYPE)类型的annotation有效\n仅针对class的继承，对interface的继承无效\n\n\n\n\n\n\n处理注解\n\n如何读取RUNTIME类型的注解\n注解定义后也是一种class，所有的注解都继承自java.lang.annotation.Annotation\n读取注解，需要使用反射API\n\n\n判断某个注解是否存在于Class、Field、Method或Constructor\nClass.isAnnotationPresent(Class)\nField.isAnnotationPresent(Class)\nMethod.isAnnotationPresent(Class)\nConstructor.isAnnotationPresent(Class)\n\n\n使用反射API读取Annotation\nClass.getAnnotation(Class)\nField.getAnnotation(Class)\nMethod.getAnnotation(Class)\nConstructor.getAnnotation(Class)\n\n\n读取方法参数的注解，先用反射获取Method实例，然后读取方法参数的所有注解\n\n\n\n泛型\n泛型\n\n泛型是编写模板代码来适应任意类型，如ArrayList&lt;T&gt;，然后为用到的类创建对应的ArrayList&lt;type&gt;\nArrayList&lt;T&gt;实现了List&lt;T&gt;接口，可以向上转型为List&lt;T&gt;\n\n\n使用泛型\n\n省略后面的Number，编译器可以自动推断泛型类型\n  List&lt;Number&gt; list = new ArrayList&lt;&gt;();\n\n除了ArrayList&lt;T&gt;使用了泛型，还可以在接口中使用泛型\n\nArrays.sort(Object[])可以对任意数组进行排序，但待排序的元素必须实现Comparable&lt;T&gt;这个泛型接口\n\n\n\n\n编写泛型\n\n编写泛型类\n\n按照某种类型，编写类\n\n标记所有特定类型\n\n特定类型String替换为T，并申明&lt;T&gt;\n  public class Pair&lt;T&gt; {    private T first;    private T last;    public Pair(T first, T last) {        this.first = first;        this.last = last;    }    public T getFirst() {        return first;    }    public T getLast() {        return last;    }}\n\n\n静态方法\n\n编写泛型类时，泛型类型&lt;T&gt;不能用于静态方法\n  public class Pair&lt;T&gt; {    private T first;    private T last;    public Pair(T first, T last) {        this.first = first;        this.last = last;    }    public T getFirst() { ... }    public T getLast() { ... }    // 静态泛型方法应该使用其他类型区分:    public static &lt;K&gt; Pair&lt;K&gt; create(K first, K last) {        return new Pair&lt;K&gt;(first, last);    }}// 将静态方法的泛型类型和实例类型的泛型类型区分开\n\n多个泛型类型\n  public class Pair&lt;T, K&gt; {    private T first;    private K last;    public Pair(T first, K last) {        this.first = first;        this.last = last;    }    public T getFirst() { ... }    public K getLast() { ... }}// 使用的时候，需要指出两种类型：Pair&lt;String, Integer&gt; p = new Pair&lt;&gt;(\"test\", 123);//Java标准库的Map&lt;K, V&gt;就是使用两种泛型类型的例子\n\n\n\n\n**Type Erasure**\n\n泛型的局限\n\n&lt;T&gt;不能是基本类型\n\n实际类型是Object，Object类型无法持有基本类型\n\n\n无法取得带泛型的Class\n\n对Pair&lt;String&gt;和Pair&lt;Integer&gt;类型获取Class时，获取到的是同一个Class，也就是Pair类的Class\n所有泛型实例，无论T的类型是什么，getClass()返回同一个Class实例，因为编译后它们全部都是Pair&lt;Object&gt;\n\n\n无法判断带泛型的类型\n\n不能实例化T类型\n\n要实例化T类型，我们必须借助额外的Class&lt;T&gt;参数\n  publicclassPair&lt;T&gt; {private T first;private T last;public Pair(Class&lt;T&gt; clazz) {        first = clazz.newInstance();        last = clazz.newInstance();    }}\n\n借助Class&lt;T&gt;参数并通过反射来实例化T类型，使用的时候必须传入Class&lt;T&gt;\n  Pair&lt;String&gt; pair = new Pair&lt;&gt;(String.class);\n\n\n覆写\n\n泛型方法要防止重复定义方法，例如：public boolean equals(T obj)；\n\n定义的equals(T t)方法实际上会被擦拭成equals(Object t)，而这个方法是继承自Object\n  public class Pair&lt;T&gt; {    public boolean equals(T t) {        return this == t;    }}// 换个方法名，避开与Object.equals(Object)的冲突// same(T t)\n\n\n泛型继承\n\n一个类可以继承自一个泛型类\n  public class IntPair extends Pair&lt;Integer&gt; {}\n\n在父类是泛型类型的情况下，编译器就必须把类型T保存到子类的class文件中\n\n在继承了泛型类型的情况下，子类可以获取父类的泛型类型\n\n\n\n\n\n**extends**通配符\n\n使用&lt;? extends Number&gt;的泛型定义称之为上界通配符Upper Bounds Wildcards\n\n泛型类型T的上界限定在Number\n\n方法参数签名setFirst(? extends Number)无法传递任何Number的子类型给setFirst(? extends Number)\n  public class Main {        public static void main(String[] args) {        Pair&lt;Integer&gt; p = new Pair&lt;&gt;(123, 456);         // incompatible types: Pair&lt;Integer&gt; cannot be converted to Pair&lt;Number&gt;        // Pair&lt;Integer&gt;不是Pair&lt;Number&gt;的子类，add(Pair&lt;Number&gt;)不接受参数类型Pair&lt;Integer&gt;        int n = add(p);        System.out.println(n);    }    static int add(Pair&lt;? extends Number&gt; p) { // add(Pair&lt;Number&gt; p)报错        Number first = p.getFirst();        Number last = p.getLast();        return first.intValue() + last.intValue();    }class Pair&lt;T&gt; {...}}\n\n作用\n\nList&lt;? extends Integer&gt;的限制：\n允许调用get()方法获取Integer的引用；\n不允许调用set(? extends Integer)方法并传入任何Integer的引用（null除外）\n对参数List&lt;? extends Integer&gt;进行只读的方法\n\n\n\n\n**super**通配符\n\nNumber和Object是Integer的父类，setFirst(Number)和setFirst(Object)实际上允许接受Integer类型\n  void set(Pair&lt;? super Integer&gt; p, Integer first, Integer last) {    p.setFirst(first);    p.setLast(last);}\n\nPair&lt;? super Integer&gt;表示，方法参数接受所有泛型类型为Integer或Integer父类的Pair类型\n\n\n作用\n\n允许调用set(? super Integer)方法传入Integer的引用\n不允许调用get()方法获得Integer的引用\n唯一例外是可以获取Object的引用：Object o = p.getFirst()\n方法内部代码对于参数只能写，不能读\n\n\n\n\n**extends**和**super**\n\n作为方法参数，&lt;? extends T&gt;类型和&lt;? super T&gt;类型的区别在于：\n\n&lt;? extends T&gt;允许调用读方法T get()获取T的引用，但不允许调用写方法set(T)传入T的引用（传入null除外）\n&lt;? super T&gt;允许调用写方法set(T)传入T的引用，但不允许调用读方法T get()获取T的引用（获取Object除外）\n\n\nCollections类定义的copy()方法\n\n第一个参数是List&lt;? super T&gt;，表示目标List，第二个参数List&lt;? extends T&gt;，表示要复制的List\n  public class Collections {    // 把src的每个元素复制到dest中:    public static &lt;T&gt; void copy(List&lt;? super T&gt; dest, List&lt;? extends T&gt; src) {        for (int i=0; i&lt;src.size(); i++) {            T t = src.get(i);            dest.add(t);        }    }}\n\n\nPECS原则\n\nProducer Extends Consumer Super\n如果需要返回T，它是生产者（Producer），使用extends通配符\n如果需要写入T，它是消费者（Consumer），使用super通配符\n\n\n\n\n无限定通配符\n\nUnbounded Wildcard Type\n  void sample(Pair&lt;?&gt; p) {}\n\n不允许调用set(T)方法并传入引用（null除外）\n\n不允许调用T get()方法并获取T引用（只能获取Object引用）\n\n只能做null判断\n\n可以用&lt;T&gt;替换，同时它是所有&lt;T&gt;类型的超类\n\n\n\n\n\n泛型和反射\n\n部分反射API是泛型，如：Class&lt;T&gt;，Constructor&lt;T&gt;\n可以声明带泛型的数组，但不能直接创建带泛型的数组，必须强制转型\n可以通过Array.newInstance(Class&lt;T&gt;, int)创建T[]数组，需要强制转型\n谨慎使用泛型和可变参数\n\n\n\n集合\n**Collection**\n\njava.util包提供了集合类：Collection，它是除Map外所有其他集合类的根接口\nList：一种有序列表的集合\nSet：一种保证没有重复元素的集合\nMap：一种通过键值（key-value）查找的映射表集合\n\n\n实现了接口和实现类相分离\n有序表的接口是List，具体的实现类有ArrayList，LinkedList等\n支持泛型，我们可以限制在一个集合中只能放入同一种数据类型的元素\n\n\n集合使用统一的Iterator遍历\n\n\n**List**\n\nArrayList在内部使用了数组来存储所有元素\n\nList&lt;E&gt;接口\n\n在末尾添加一个元素：boolean add(E e)\n在指定索引添加一个元素：boolean add(int index, E e)\n删除指定索引的元素：E remove(int index)\n删除某个元素：boolean remove(Object e)\n获取指定索引的元素：E get(int index)\n获取链表大小（包含元素的个数）：int size()\n\n\n实现List接口\n\nArrayList通过数组实现\n\nLinkedList通过链表实现\n\nArrayList和LinkedList\n\n\n\n\nArrayList\nLinkedList\n\n\n\n获取指定元素\n很快\n从头查找\n\n\n添加元素到末尾\n很快\n很快\n\n\n指定位置添加或删除\n需要移动元素\n不需要移动元素\n\n\n内存占用\n少\n较大\n\n\n\n\n\nList的特点\n\nList内部的元素可以重复\n允许添加null\n\n\n创建List\n\n除了ArrayList和LinkedList\n\nof()方法（不接受null）\n  List&lt;Integer&gt; list = List.of(1, 2, 5);\n\n\n遍历List\n\nfor循环根据索引配合get(int)方法遍历\nIterator\n由List的实例调用iterator()方法的时候创建\n  public class Main {    public static void main(String[] args) {        List&lt;String&gt; list = List.of(\"apple\", \"pear\", \"banana\");        for (Iterator&lt;String&gt; it = list.iterator(); it.hasNext(); ) {            String s = it.next();            System.out.println(s);        }    }}\n\nfor each循环\n  public class Main {    public static void main(String[] args) {        List&lt;String&gt; list = List.of(\"apple\", \"pear\", \"banana\");        for (String s : list) {            System.out.println(s);        }    }}\n\n实现了Iterable接口的集合类都可以直接用for each循环来遍历\n\n\n\n\n\nList和Array转换\n\n调用toArray()方法直接返回一个Object[]数组\n\ntoArray(T[])传入一个类型相同的Array，List内部自动把元素复制到传入的Array\n\nInteger[] **array** = **list**.toArray(**new** Integer[**list**.size()]);\n\n\nInteger[] **array** = **list**.toArray(Integer[]::**new**);\n\n\nArray -→ List\n\n**List**&lt;Integer&gt; **list** = **List**.of(**array**); （只读）\n\n\n\n\n找出List缺失的数字\n  private static int findMissingNumber2(int start, int end, ArrayList&lt;Integer&gt; list) {  int sum1 = 0;  int max = start;  int min = end;  for (int n : list) {    sum1 += n;    if (n &gt; max) max = n;    if (n &lt; min) min = n;  }   int sum2 = (min + max) * (list.size() + 1) / 2;  if (start != min) return start;  if (end != max) return end;  return sum2 - sum1;}\n\n\n**equals**\n\nList提供\nboolean contains(Object o)方法来判断List是否包含某个指定元素\nint indexOf(Object o)方法返回元素的索引，如果元素不存在,返回-1\n放入的实例必须正确覆写equals()方法\n\n\nequals()方法要求\n自反性（Reflexive）\n\n对称性（Symmetric）\n\n传递性（Transitive）\n\n一致性（Consistent）\n\n对null的比较：即x.equals(null)永远返回false\n\n对于Person类\n  public boolean equals(Object o) {    if (o instanceof Person p) {        return this.name.equals(p.name) &amp;&amp; this.age == p.age;    }    return false;}// 引用字段比较使用equals()，基本类型字段的比较使用==\n\n简化引用类型的比较，使用Objects.equals()静态方法\n  public boolean equals(Object o) {    if (o instanceof Person p) {        return Objects.equals(this.name, p.name) &amp;&amp; this.age == p.age;    }    return false;}\n\n\n\n\n**Map**\n\nMap&lt;K, V&gt;是一种键-值映射表\n当调用put(K key, V value)方法时，就把key和value做了映射并放入Map\n当我们调用V get(K key)时，就可以通过key获取到对应的value\n如果key不存在，则返回null\nList类似，Map也是一个接口，最常用的实现类是HashMap\n查询某个key是否存在，调用boolean containsKey(K key)方法\nMap中不存在重复的key，放入相同的key，只会把原有的value给替换掉\n\n\n遍历Map\nfor each循环遍历Map实例keySet()方法返回的Set集合，包含不重复的key集合\n  for (String key : map.keySet()) {...}\n\nfor each循环遍历Map对象的entrySet()集合，包含每一个key-value映射\n  for (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) {};\n\n\n\n\n编写**equals**和**hashCode**\n\nMap\n作为key的对象必须正确覆写equals()方法，相等的两个key实例调用equals()必须返回true\n作为key的对象还必须正确覆写hashCode()方法，且hashCode()方法要严格遵循以下规范\n如果两个对象相等，则两个对象的hashCode()必须相等\n如果两个对象不相等，则两个对象的hashCode()尽量不要相等\n\n\n编写equals()和hashCode()遵循的原则是\nequals()用到的用于比较的每一个字段，都必须在hashCode()中用于计算\nequals()中没有使用到的字段，绝不可放在hashCode()中计算\n实现hashCode()方法可以通过Objects.hashCode()辅助方法实现\n\n\n创建HashMap时指定容量\n\n\n\n\nEnumMap\n\n如果Map的key是enum类型，使用EnumMap\n\n\nTreeMap\n\nSortedMap 在内部会对Key进行排序，实现类是TreeMap\n使用TreeMap时，放入的Key必须实现Comparable接口\n如果作为Key的class没有实现Comparable接口，在创建TreeMap时同时必须指定一个自定义排序算法\n\n严格按照compare()规范实现比较逻辑\n\n定义Student类，并用分数score进行排序，高分在前\n  import java.util.*;public class Main {    public static void main(String[] args) {        Map&lt;Student, Integer&gt; map = new TreeMap&lt;&gt;(new Comparator&lt;Student&gt;() {            public int compare(Student p1, Student p2) {\t\t\t\t\t\t    if (p1.score == p2.score) {\t\t\t\t\t\t        return 0;\t\t\t\t\t\t    }\t\t\t\t\t\t    return p1.score &gt; p2.score ? -1 : 1;\t\t\t\t\t\t}// or: Integer.compare(int, int)        });        map.put(new Student(\"Tom\", 77), 1);        map.put(new Student(\"Bob\", 66), 2);        map.put(new Student(\"Lily\", 99), 3);        for (Student key : map.keySet()) {            System.out.println(key);        }        System.out.println(map.get(new Student(\"Bob\", 66))); // null?    }}class Student {    public String name;    public int score;    Student(String name, int score) {        this.name = name;        this.score = score;    }    public String toString() {        return String.format(\"{%s: score=%d}\", name, score);    }}\n\n\n\n\nProperties\n\n读取配置文件\n\n创建Properties实例\n\n调用load()读取文件\n\n调用getProperty()获取配置（覆盖配置）\n  String f = \"setting.properties\";Properties props = new Properties();props.load(new java.io.FileInputStream(f));// props.load(getClass().getResourceAsStream(\"/common/setting.properties\"));String filepath = props.getProperty(\"last_open_file\");String interval = props.getProperty(\"auto_save_interval\", \"120\");\n\n\n写入配置文件\n\nsetProperty()修改了Properties实例\n写入配置文件使用store()\n\n\n编码\n\n使用重载方法load(Reader)读取\n  Properties props = new Properties();props.load(new FileReader(\"settings.properties\", StandardCharsets.UTF_8));// InputStream和Reader的区别是一个是字节流，一个是字符流\n\n\n\n\nSet\n\nSet用于存储不重复的元素集合\n将元素添加进Set&lt;E&gt;：boolean add(E e)\n将元素从Set&lt;E&gt;删除：boolean remove(Object e)\n判断是否包含元素：boolean contains(Object e)\n\n\n放入Set的元素和Map的key类似，都要正确实现equals()和hashCode()方法\n最常用的Set实现类是HashSet\nSet接口并不保证有序\nHashSet是无序的，实现了Set接口，并没有实现SortedSet接口\nTreeSet是有序的，实现了SortedSet接口\n使用TreeSet和使用TreeMap的要求一样\n添加的元素必须正确实现Comparable接口\n如果没有实现Comparable接口，创建TreeSet时必须传入一个Comparator对象\n\n\n\n\n\n\nQueue\n\nQueue是实现了一个先进先出（FIFO）的有序表\n\nint size()：获取队列长度\nboolean add(E)/boolean offer(E)：添加元素到队尾\nE remove()/E poll()：获取队首元素并从队列中删除\nE element()/E peek()：获取队首元素但并不从队列中删除\n\n\n两个方法（要避免把null添加到队列）\n\n\n\n\nthrow Exception\n返回false或null\n\n\n\n添加元素到队尾\nadd(E e)\nboolean offer(E e)\n\n\n取队首元素并删除\nE remove()\nE poll()\n\n\n取队首元素但不删除\nE element()\nE peek()\n\n\n\nLinkedList即实现了List接口，又实现了Queue接口\n  // 这是一个List:List&lt;String&gt; list = new LinkedList&lt;&gt;();// 这是一个Queue:Queue&lt;String&gt; queue = new LinkedList&lt;&gt;();\n\n\nPriorityQueue\n\n放入PriorityQueue的元素必须实现Comparable接口，or通过Comparator自定义排序算法，根据元素排序顺序决定出队优先级\n\n\nDeque\n\nDouble Ended Queue\n\n\n\n\nQueue\nDeque\n\n\n\n添加元素到队尾\nadd(E e) / offer(E e)\naddLast(E e) / offerLast(E e)\n\n\n取队首元素并删除\nE remove() / E poll()\nE removeFirst() / E pollFirst()\n\n\n取队首元素但不删除\nE element() / E peek()\nE getFirst() / E peekFirst()\n\n\n添加元素到队首\n无\naddFirst(E e) / offerFirst(E e)\n\n\n取队尾元素并删除\n无\nE removeLast() / E pollLast()\n\n\n取队尾元素但不删除\n无\nE getLast() / E peekLast()\n\n\n\nDeque接口实际上扩展自Queue\n\n调用xxxFirst()/xxxLast()以便与Queue的方法区分开；\n避免把null添加到队列\n\n\nDeque是一个接口，它的实现类有ArrayDeque和LinkedList\n\n\n\nStack\n\n栈（Stack）是一种后进先出（LIFO）的数据结构\n把元素压栈：push(E)\n把栈顶的元素“弹出”：pop()\n取栈顶元素但不弹出：peek()\n\n\nDeque可以实现Stack的功能\npush(E)/addFirst(E)\npop()/removeFirst()\npeek()/peekFirst()\n\n\n作用\nJVM在处理Java方法调用的时候就会通过栈这种数据结构维护方法调用的层次\nJVM会创建方法调用栈，每调用一个方法时\n先将参数压栈，然后执行对应的方法\n当方法返回时，返回值压栈，调用方法通过出栈操作获得方法返回值\n嵌套调用过多会造成栈溢出，引发StackOverflowError\n\n\n\n\n整数的进制转换\n计算中缀表达式\n\n\n\n\nIterator\n\n通过Iterator对象遍历集合的模式称为迭代器\n  import java.util.*;public class Main {    public static void main(String[] args) {        ReverseList&lt;String&gt; rlist = new ReverseList&lt;&gt;();        rlist.add(\"Apple\");        rlist.add(\"Orange\");        rlist.add(\"Pear\");        for (String s : rlist) {            System.out.println(s);        }    }}class ReverseList&lt;T&gt; implements Iterable&lt;T&gt; {    private List&lt;T&gt; list = new ArrayList&lt;&gt;();    public void add(T t) {        list.add(t);    }    @Override    public Iterator&lt;T&gt; iterator() {        return new ReverseIterator(list.size());    }    class ReverseIterator implements Iterator&lt;T&gt; {        int index;        ReverseIterator(int index) {            this.index = index;        }        @Override        public boolean hasNext() {            return index &gt; 0;        }        @Override        public T next() {            index--;            return ReverseList.this.list.get(index);        }    }}\n\n\nCollections\n\naddAll()方法可以给一个Collection类型的集合添加若干元素\n  public static boolean addAll(Collection&lt;? super T&gt; c, T... elements) { ... }\n\n创建空集合\n\n创建空List：List&lt;T&gt; emptyList()\n\n创建空Map：Map&lt;K, V&gt; emptyMap()\n\n创建空Set：Set&lt;T&gt; emptySet()\n\n返回的空集合是不可变集合，无法向其中添加或删除元素\n\n集合接口提供的of(T...)方法创建空集合\n  List&lt;String&gt; list1 = List.of();List&lt;String&gt; list2 = Collections.emptyList();\n\n\n创建单元素集合\n\n单元素集合也是不可变集合\n创建一个元素的List：List&lt;T&gt; singletonList(T o)\n创建一个元素的Map：Map&lt;K, V&gt; singletonMap(K key, V value)\n创建一个元素的Set：Set&lt;T&gt; singleton(T o)\n\n\n使用List.of(T...)，可以创建空集合，单元素集合，任意个元素的集合\n\n排序：Collections.sort(list);\n\n洗牌：Collections.shuffle(list);\n\n不可变集合\n\n封装成不可变List：List&lt;T&gt; unmodifiableList(List&lt;? extends T&gt; list)\n封装成不可变Set：Set&lt;T&gt; unmodifiableSet(Set&lt;? extends T&gt; set)\n封装成不可变Map：Map&lt;K, V&gt; unmodifiableMap(Map&lt;? extends K, ? extends V&gt; m)\n对原始的可变List进行增删是可以的，并且会直接影响到封装后的“不可变”List\n\n\n\n\n\nIO\nIO\n\nIO是指Input/Output\nInputStream / OutputStream\nIO流以byte（字节）为最小单位，因此也称为字节流\n\n\nReader / Writer\n字符流\nJava提供了Reader和Writer表示字符流，传输的最小数据单位是char\n\n\n同步和异步\nJava标准库的java.io包提供了同步IO功能\n同步IO\n读写IO时代码必须等待数据返回后才继续执行后续代码\n优点是代码编写简单，缺点是CPU执行效率低\n\n\n异步IO\n读写IO时仅发出请求，然后立刻执行后续代码\n优点是CPU执行效率高，缺点是代码编写复杂\n\n\n\n\n\n\nFile\n\nFile对象\nJava的标准库java.io提供了File对象来操作文件和目录\n构造File对象时，既可以传入绝对路径，也可以传入相对路径\nFile对象有3种形式表示的路径\ngetPath()返回构造方法传入的路径\ngetAbsolutePath()返回绝对路径\ngetCanonicalPath返回的是规范路径，和绝对路径类似\n\n\n\n\n文件和目录\nFile对象既可以表示文件，也可以表示目录\n构造一个File对象不会导致任何磁盘操作\n调用File对象的某些方法时才真正进行磁盘操作\n\n\nFile对象获取到一个文件时，判断文件的权限和大小\nboolean canRead()\nboolean canWrite()\nboolean canExecute()\nlong length()\n\n\n\n\n创建和删除文件\ncreateNewFile()创建一个新文件\ndelete()删除该文件\ncreateTempFile()来创建一个临时文件\ndeleteOnExit()在JVM退出时自动删除该文件\n\n\n遍历文件和目录\nlist()和listFiles()列出目录下的文件和子目录名\nFile对象如果表示一个目录\nboolean mkdir()：创建当前File对象表示的目录\nboolean mkdirs()：创建当前File对象表示的目录，并在必要时将不存在的父目录也创建出来\nboolean delete()：删除当前File对象表示的目录，当前目录必须为空才能删除成功\n\n\n\n\nPath\nPath对象位于java.nio.file包\n\n如果需要对目录进行复杂的拼接、遍历等操作，使用Path对象更方便\n  import java.io.*;import java.nio.file.*;public class Main {    public static void main(String[] args) throws IOException {        Path p1 = Paths.get(\".\", \"project\", \"study\"); // 构造一个Path对象        System.out.println(p1);        Path p2 = p1.toAbsolutePath(); // 转换为绝对路径        System.out.println(p2);        Path p3 = p2.normalize(); // 转换为规范路径        System.out.println(p3);        File f = p3.toFile(); // 转换为File对象        System.out.println(f);        for (Path p : Paths.get(\"..\").toAbsolutePath()) { // 可以直接遍历Path            System.out.println(\"  \" + p);        }    }}\n\n\n\n\nInputStream\n\nInputStream\n\nJava标准库提供的最基本的输入流\n\n位于packagejava.io，提供了所有同步IO的功能\n\n不是一个接口，而是一个抽象类，它是所有输入流的超类\n\n抽象类定义的一个最重要的方法就是int read()\n\n方法签名\n  public abstract int read() throws IOException;\n\nFileInputStream是InputStream的一个子类，从文件流中读取数据\n  public void readFile() throws IOException {    // 创建一个FileInputStream对象:    InputStream input = new FileInputStream(\"src/readme.txt\");    for (;;) {        int n = input.read(); // 反复调用read()方法，直到返回-1        if (n == -1) {            break;        }        System.out.println(n); // 打印byte的值    }    input.close(); // 关闭流}\n\n用try ... finally来保证InputStream在无论是否发生IO错误的时候都能够正确地关闭\n\ntry(resource)\n  public void readFile() throws IOException {    try (InputStream input = new FileInputStream(\"src/readme.txt\")) {        int n;        while ((n = input.read()) != -1) {            System.out.println(n);        }    } // 编译器在此自动为我们写入finally并调用close()}\n\n\n\n\n缓冲\n\nInputStream提供了两个重载方法来支持读取多个字节\nint read(byte[] b)：读取若干字节并填充到byte[]数组，返回读取的字节数\nint read(byte[] b, int off, int len)：指定byte[]数组的偏移量和最大填充数\n\n\n\n\n阻塞\n\n在调用InputStream的read()方法读取数据时，read()方法是阻塞Blocking\n  int n;n = input.read(); // 必须等待read()方法返回才能执行下一行代码int m = n;\n\n\nInputStream实现类\n\nFileInputStream从文件获取输入流\nByteArrayInputStream在内存中模拟一个InputStream\n\n\n\n\nOutputStream\n\nOutputStream\nJava标准库提供的最基本的输出流\n\n是抽象类，是所有输出流的超类\n\n抽象类定义的一个最重要的方法就是void write(int b)\n\n方法签名\n  public abstract void write(int b) throws IOException;\n\n缓冲区、flush()\n\n\n\nFileOutputStream\n一次性写入若干字节，OutputStream提供的重载方法void write(byte[])\n  public void writeFile() throws IOException {    OutputStream output = new FileOutputStream(\"out/readme.txt\");    output.write(\"Hello\".getBytes(\"UTF-8\")); // Hello    output.close();}\n\ntry(resource)来保证OutputStream在无论是否发生IO错误时都能正确地关闭\n  public void writeFile() throws IOException {    try (OutputStream output = new FileOutputStream(\"out/readme.txt\")) {        output.write(\"Hello\".getBytes(\"UTF-8\")); // Hello    } // 编译器在此自动为我们写入finally并调用close()}\n\n阻塞\n\n和InputStream一样，OutputStream的write()方法也是阻塞的\n\n\n\n\nOutputStream实现类\nFileOutputStream从文件获取输出流\nByteArrayOutputStream可以在内存中模拟一个OutputStream\n\n\n\n\n**Filter**模式\n\n为了解决依赖继承会导致子类数量失控的问题，JDK将InputStream分为两大类\n一类是直接提供数据的基础InputStream，如：\nFileInputStream\nByteArrayInputStream\nServletInputStream\n\n\n一类是提供额外附加功能的InputStream，如：\nBufferedInputStream\nDigestInputStream\nCipherInputStream\n\n\n一个基础组件叠加各种附加功能组件的模式，称为Filter模式/装饰器模式Decorator\n\n\n编写FilterInputStream\n\n\n操作**Zip**\n\nZipInputStream是一种FilterInputStream，可以直接读取zip包的内容\n\n读取zip包\n\n创建一个ZipInputStream，通常是传入一个FileInputStream作为数据源，然后循环调用getNextEntry()，直到返回null，表示zip流结束\n\n一个ZipEntry表示一个压缩文件或目录，如果是压缩文件，我们就用read()方法不断读取，直到返回-1：\n  try (ZipInputStream zip = new ZipInputStream(new FileInputStream(...))) {    ZipEntry entry = null;    while ((entry = zip.getNextEntry()) != null) {        String name = entry.getName();        if (!entry.isDirectory()) {            int n;            while ((n = zip.read()) != -1) {                ...            }        }    }}\n\n\n写入zip包\n\n创建一个ZipOutputStream，通常是包装一个FileOutputStream，然后，每写入一个文件前，先调用putNextEntry()，然后用write()写入byte[]数据，写入完毕后调用closeEntry()结束这个文件的打包\n  try (ZipOutputStream zip = new ZipOutputStream(new FileOutputStream(...))) {    File[] files = ...    for (File file : files) {        zip.putNextEntry(new ZipEntry(file.getName()));        zip.write(Files.readAllBytes(file.toPath()));        zip.closeEntry();    }}\n\n\n\n\n读取**classpath**资源\n\nJava程序启动时需要从一个.properties文件中读取配置\n\n从classpath读取文件可以避免不同环境下文件路径不一致的问题\n\n把default.properties文件放到classpath中，就不用关心它的实际存放路径\n\n\n在classpath中的资源文件，路径总是以／开头，我们先获取当前的Class对象，然后调用getResourceAsStream()就可以直接从classpath读取任意的资源文件\n  try (InputStream input = getClass().getResourceAsStream(\"/default.properties\")) {    if (input != null) {        // TODO:    }}\n\n\n序列化\n\n序列化\n\n是指把一个Java对象变成二进制内容，本质上就是一个byte[]数组\n序列化后可以把byte[]保存到文件中，或者把byte[]通过网络传输到远程\n\n\n反序列化\n\n把一个二进制内容（byte[]数组）变回Java对象\n保存到文件中的byte[]数组又可以变回Java对象，或者从网络上读取byte[]并把它变回Java对象\n\n\n序列化\n\n一个Java对象要能序列化，必须实现一个特殊的java.io.Serializable接口\n  public interface Serializable {...}\n\nSerializable接口没有定义任何方法，是一个空接口，称为标记接口Marker Interface\n\n\n一个Java对象变为byte[]数组，需要使用ObjectOutputStream\n  import java.io.*;import java.util.Arrays;public class Main {    public static void main(String[] args) throws IOException {        ByteArrayOutputStream buffer = new ByteArrayOutputStream();        try (ObjectOutputStream output = new ObjectOutputStream(buffer)) {            // 写入int:            output.writeInt(12345);            // 写入String:            output.writeUTF(\"Hello\");            // 写入Object，实现了Serializable接口的Object            output.writeObject(Double.valueOf(123.456));        }        System.out.println(Arrays.toString(buffer.toByteArray()));    }}\n\n\n反序列化\n\n和ObjectOutputStream相反，ObjectInputStream负责从一个字节流读取Java对象\n  try (ObjectInputStream input = new ObjectInputStream(...)) {    int n = input.readInt();    String s = input.readUTF();    Double d = (Double) input.readObject();}\n\n除了能读取基本类型和String类型外，调用readObject()可以直接返回一个Object对象。要把它变成一个特定类型，必须强制转型。readObject()可能抛出的异常有：\n\nClassNotFoundException：没有找到对应的Class\nInvalidClassException：Class不匹配\n\n\n反序列化时\n\n由JVM直接构造出Java对象\n不调用构造方法，构造方法内部的代码，在反序列化时根本不可能执行\n\n\n\n\n\n\nReader\n\njava.io.Reader是所有字符输入流的超类，最主要的方法是\n  publicint read()throws IOException;\n\nReader是Java的IO库提供的另一个输入流接口\n\nInputStream是一个字节流，即以byte为单位读取\n\nReader是一个字符流，即以char为单位读取\n\n对比\n\n\n\nInputStream\nReader\n\n\n\n字节流，以byte为单位\n字符流，以char为单位\n\n\n读取字节（-1，0~255）：int read()\n读取字符（-1，0~65535）：int read()\n\n\n读到字节数组：int read(byte[] b)\n读到字符数组：int read(char[] c)\n\n\n\n\n\nFileReader\n\n是Reader的一个子类，它可以打开文件并获取Reader\n  public void readFile() throws IOException {    // 创建一个FileReader对象:    Reader reader = new FileReader(\"src/readme.txt\", StandardCharsets.UTF_8);    for (;;) {        int n = reader.read(); // 反复调用read()方法，直到返回-1        if (n == -1) {            break;        }        System.out.println((char)n); // 打印char    }    reader.close(); // 关闭流}// 创建FileReader时指定编码，避免乱码\n\ntry (resource)来保证Reader在无论有没有IO错误的时候都能够正确地关闭\n\n一次性读取若干字符并填充到char[]数组\n  public int read(char[] c) throws IOException\n\n返回实际读入的字符个数，最大不超过char[]数组的长度\n返回-1表示流结束\n\n\n\n\nCharArrayReader\n\nCharArrayReader可以在内存中模拟一个Reader\n\n实际上是把一个char[]数组变成一个Reader，和ByteArrayInputStream类似\n  try (Reader reader =new CharArrayReader(\"Hello\".toCharArray())) {}\n\n\nStringReader\n\nStringReader可以直接把String作为数据源，它和CharArrayReader几乎一样\n  try (Reader reader =new StringReader(\"Hello\")) {}\n\n\nInputStreamReader\n\n可以把任何InputStream转换为Reader\n\n构造InputStreamReader时，需要传入InputStream，需要指定编码，得到Reader对象\n\n通过try (resource)：\n  try (Reader reader =new InputStreamReader(new FileInputStream(\"src/readme.txt\"), \"UTF-8\")) {// TODO:}\n\n实际上就是FileReader的一种实现方式\n\n使用try (resource)结构时，当我们关闭Reader时，它会在内部自动调用InputStream的close()方法，所以，只需要关闭最外层的Reader对象即可。\n\n使用InputStreamReader，可以把一个InputStream转换成一个Reader\n\n\n\n\n\nWriter\n\nWriter\n\nReader是带编码转换器的InputStream，把byte转换为char\nWriter就是带编码转换器的OutputStream，把char转换为byte并输出\n\n\nWriter和OutputStream\n\n\n\nOutputStream\nWriter\n\n\n\n字节流，以byte为单位\n字符流，以char为单位\n\n\n写入字节（0~255）：void write(int b)\n写入字符（0~65535）：void write(int c)\n\n\n写入字节数组：void write(byte[] b)\n写入字符数组：void write(char[] c)\n\n\n无对应方法\n写入String：void write(String s)\n\n\n\nWriter是所有字符输出流的超类\n\nvoid write(int c)\nvoid write(char[] c)\nvoid write(String s)\n\n\nFileWriter\n\nFileWriter就是向文件中写入字符流的Writer。使用方法和FileReader类似\n  try (Writer writer =new FileWriter(\"readme.txt\", StandardCharsets.UTF_8)) {    writer.write('H');// 写入单个字符    writer.write(\"Hello\".toCharArray());// 写入char[]    writer.write(\"Hello\");// 写入String}\n\n\nCharArrayWriter\n\nCharArrayWriter可以在内存中创建一个Writer\n\n实际上是构造一个缓冲区，可以写入char，最后得到写入的char[]数组，和ByteArrayOutputStream非常类似\n  try (CharArrayWriter writer =new CharArrayWriter()) {    writer.write(65);    writer.write(66);    writer.write(67);char[] data = writer.toCharArray();// { 'A', 'B', 'C' }}\n\n\nStringWriter\n\nStringWriter也是一个基于内存的Writer，和CharArrayWriter类似\nStringWriter在内部维护了一个StringBuffer，并对外提供了Writer接口\n\n\nOutputStreamWriter\n\n除CharArrayWriter和StringWriter外，普通Writer实际上是基于OutputStream构造的\n\n接收char，然后在内部自动转换成一个或多个byte，并写入OutputStream\n\n因此，OutputStreamWriter就是一个将任意的OutputStream转换为Writer的转换器\n  try (Writer writer =new OutputStreamWriter(new FileOutputStream(\"readme.txt\"), \"UTF-8\")) {// TODO:}\n\n上述代码实际上就是FileWriter的一种实现方式\n\n\n\n\n\nPrintStream和PrintWriter\n\nPrintStream\n一种FilterOutputStream，在OutputStream接口上，提供写入各种数据类型的方法\n写入int：print(int)\n写入boolean：print(boolean)\n写入String：print(String)\n写入Object：print(Object)，实际上相当于print(object.toString())\nSystem.out是标准输出；\nSystem.err是标准错误输出\n\n\nPrintWriter\nPrintStream最终输出是byte数据，PrintWriter则是扩展了Writer接口，它的print()/println()方法最终输出的是char数据\n\n\n\n\n使用**Files**\n\n是java.nio包里面的类\n对于简单的小文件读写操作，可以使用Files工具类\n\n\n\n日期与时间\n**Date &amp; Time**\n以GMT或者UTC加时区偏移表示\n如：GMT+08:00或者UTC+08:00表示东八区\n本地化\nLocale表示一个国家或地区的日期、时间、数字、货币等格式\nLocale由语言_国家的字母缩写构成\n如，zh_CN表示中文+中国，en_US表示英文+美国\n\n\n\n\n\n\nDate &amp; Calendar\nEpoch Time\n\n时间戳，几种存储方式\n\n以秒为单位的整数\n以毫秒为单位的整数\n以秒为单位的浮点数\n\n\n通常是用long表示的毫秒数，即：\n  long t = 1574208900123L;\n\n获取当前时间戳，使用System.currentTimeMillis()\n\n\n\n标准库API\n\njava.utilpackage\n主要包括Date、Calendar和TimeZone\n\n\njava.timepackage\n主要包括LocalDateTime、ZonedDateTime、ZoneId\n\n\n\n\nDate\n\njava.util.Date是用于表示一个日期和时间的对象\n用法示例\nDate对象\n不能转换时区，除了toGMTString()可以按GMT+0:00输出外\n很难对日期和时间进行加减\n\n\n\n\nCalendar\n\n用于获取并设置年、月、日、时、分、秒\n只有一种方式获取即Calendar.getInstance()，而且获取到是当前时间\nCalendar.getTime()可以将一个Calendar对象转换成Date对象\n\n\nTimeZone\n\nCalendar和Date相比，它提供了时区转换的功能\n\n\n\n\nLocalDateTime\njava.time包提供了新的日期和时间API\n本地日期和时间：LocalDateTime，LocalDate，LocalTime\n带时区的日期和时间：ZonedDateTime\n时刻：Instant\n时区：ZoneId，ZoneOffset\n时间间隔：Duration\n格式化类型：DateTimeFormatter\n\n\nLocalDateTime、DateTimeFormatter、Duration和Period\nDuration表示两个时刻之间的时间间隔、Period表示两个日期之间的天数\nLocalDateTime可以非常方便地对日期和时间进行加减，或者调整日期和时间，它总是返回新对象\n使用isBefore()和isAfter()可以判断日期和时间的先后\n使用Duration和Period可以表示两个日期和时间的“区间间隔”\n\n\n\n\nZonedDateTime\n带时区的日期和时间\nLocalDateTime加ZoneId\n\n\n时区转换\nZonedDateTime对象\nwithZoneSameInstant()将关联时区转换到另一个时区\n\n\n\n\nDateTimeFormatter\n不变对象、线程安全\n对ZonedDateTime或LocalDateTime进行格式化，需要使用DateTimeFormatter\nDateTimeFormatter可以通过格式化字符串和Locale对日期和时间进行定制输出\n\n\nInstant\nSystem.currentTimeMillis()返回的就是以毫秒表示的当前时间戳\n在java.time中以Instant类型表示，用Instant.now()获取当前时间戳\n\n\nInstant表示高精度时间戳，它可以和ZonedDateTime以及long互相转换\n\n\n\n单元测试\n编写**JUnit**测试\n\n单元测试代码本身必须非常简单，能一下看明白，决不能再为测试代码编写测试\n\n每个单元测试应当互相独立，不依赖运行的顺序\n\n测试时不但要覆盖常用测试用例，还要特别注意测试边界条件，例如输入为0，null，空字符串\"\"等情况\n\nFactorialTest.java\n  package com.itranswarp.learnjava;import static org.junit.jupiter.api.Assertions.*;import org.junit.jupiter.api.Test;public class FactorialTest {    @Test    void testFact() {        assertEquals(1, Factorial.fact(1));        assertEquals(2, Factorial.fact(2));        assertEquals(6, Factorial.fact(3));        assertEquals(3628800, Factorial.fact(10));        assertEquals(2432902008176640000L, Factorial.fact(20));    }}\n\n\n使用Fixture\n\n编写测试前准备、测试后清理的固定代码\n对于实例变量，在@BeforeEach中初始化，在@AfterEach中清理\n在各个@Test方法中互不影响，因为是不同的实例\n\n\n对于静态变量，在@BeforeAll中初始化，在@AfterAll中清理\n在各个@Test方法中均是唯一实例，会影响各个@Test方法\n\n\n\n\n\n\n异常测试\n\nassertThrows()期望捕获一个指定异常、第二个参数封装了要执行的会产生异常的代码\n  @Testvoid testNegative() {    assertThrows(IllegalArgumentException.class, () -&gt; {        Factorial.fact(-1);    });}\n\n\n条件测试\n\n根据某些注解在运行期让JUnit自动忽略某些测试\n\n\n参数化测试\n\n@ParameterizedTest注解，进行参数化测试\n参数传入\n@MethodSource\n编写一个同名的静态方法来提供测试参数\n\n\n@CsvSource\n每一个字符串表示一行\n\n\n@CsvFileSource\n\n\n\n\n\n正则表达式\n正则表达式\n\njava.util.regex包\n用字符串来描述规则，并用来匹配字符串\n\n\n匹配规则\n\n单字符\n\n\n\n正则表达式\n规则\n可以匹配\n\n\n\nA\n指定字符\nA\n\n\n\\u548c\n指定Unicode字符\n和\n\n\n.\n任意字符\na，b，&amp;，0\n\n\n\\d\n数字0~9\n0~9\n\n\n\\w\n大小写字母，数字和下划线\naz，AZ，0~9，_\n\n\n\\s\n空格、Tab键\n空格，Tab\n\n\n\\D\n非数字\na，A，&amp;，_，……\n\n\n\\W\n非\\w\n&amp;，@，中，……\n\n\n\\S\n非\\s\na，A，&amp;，_，……\n\n\n\n多个字符\n\n\n\n正则表达式\n规则\n可以匹配\n\n\n\nA*\n任意个数字符\n空，A，AA，AAA，……\n\n\nA+\n至少1个字符\nA，AA，AAA，……\n\n\nA?\n0个或1个字符\n空，A\n\n\nA{3}\n指定个数字符\nAAA\n\n\nA{2,3}\n指定范围个数字符\nAA，AAA\n\n\nA{2,}\n至少n个字符\nAA，AAA，AAAA，……\n\n\nA{0,3}\n最多n个字符\n空，A，AA，AAA\n\n\n\n\n\n复杂匹配规则\n\n匹配开头和结尾\n^表示开头，$表示结尾\n\n\n匹配指定范围\n[...]匹配范围内的字符\n[1-9]\n[0-9a-fA-F] 、六位[0-9a-fA-F]{6}\n\n\n不包含指定范围的字符\n[^1-9]{3}\n\n\n\n\n或规则匹配\n|连接的两个正则规则是或规则\n\n\n使用括号\n公共部分提出来，(...)把子规则括起来成learn\\\\s(java|php|go)\n\n\n\n\n分组匹配\n\n引入java.util.regex包\n(...)先分组，用Pattern对象匹配\n匹配后获得一个Matcher对象\n如果匹配成功，从Matcher.group(index)返回子串\nMatcher.group(index)方法的参数\n0即整个正则匹配到的字符串\n\n1表示第一个子串，2表示第二个子串\n  import java.util.regex.*;public class Main {    public static void main(String[] args) {        Pattern pattern = Pattern.compile(\"(\\\\d{3,4})\\\\-(\\\\d{7,8})\");        pattern.matcher(\"010-12345678\").matches(); // true        pattern.matcher(\"021-123456\").matches(); // false        pattern.matcher(\"022#1234567\").matches(); // false        // 获得Matcher对象:        Matcher matcher = pattern.matcher(\"010-12345678\");        if (matcher.matches()) {            String whole = matcher.group(0); // \"010-12345678\", 0表示匹配的整个字符串            String area = matcher.group(1); // \"010\", 1表示匹配的第1个子串            String tel = matcher.group(2); // \"12345678\", 2表示匹配的第2个子串            System.out.println(area);            System.out.println(tel);        }    }}\n\n\n\n\n\n\n非贪婪匹配\n\n正则表达式匹配默认贪婪匹配，使用?表示对某一规则进行非贪婪匹配\n\n\n搜索和替换\n\n分割字符串\n\nString.split()方法传入正则表达式\n\n\n搜索字符串\n\n获取到Matcher对象后，反复调用find()方法，搜索能匹配上\\\\wo\\\\w规则的子串\n  public class Main {    public static void main(String[] args) {        String s = \"the quick brown fox jumps over the lazy dog.\";        Pattern p = Pattern.compile(\"\\\\wo\\\\w\");        Matcher m = p.matcher(s);        while (m.find()) {            String sub = s.substring(m.start(), m.end());            System.out.println(sub);        }    }}\n\n\n替换字符串\n\nString.replaceAll()（正则表达式，待替换的字符串）\n\n\n反向引用\n\n把任何4字符单词的前后用&lt;b&gt;xxxx&lt;/b&gt;括起来\n\n\" &lt;b&gt;$1&lt;/b&gt; \"用匹配的分组子串([a-z]{4})替换了$1\n\n  public class Main {    public static void main(String[] args) {        String s = \"the quick brown fox jumps over the lazy dog.\";        String r = s.replaceAll(\"\\\\s([a-z]{4})\\\\s\", \" &lt;b&gt;$1&lt;/b&gt; \");        System.out.println(r);    }}// the quick brown fox jumps &lt;b&gt;over&lt;/b&gt; the &lt;b&gt;lazy&lt;/b&gt; dog.\n\n\n\n\n\n多线程\n多线程基础\n\n进程\n一个任务称为一个进程\n子任务称为线程\n一个进程可以包含一个或多个线程，但至少会有一个线程\n\n\n\n\n创建新线程\n\n实例化一个Thread实例，调用start()方法\n\n一个线程对象只能调用一次start()方法\n\n线程的执行代码写在run()方法中\n线程调度由操作系统决定，程序本身无法决定调度顺序\nThread.sleep()可以把当前线程暂停一段时间\n\n\n从Thread派生一个自定义类，然后覆写run()方法\n  public class Main {    public static void main(String[] args) {        Thread t = new MyThread();        t.start(); // 启动新线程    }}class MyThread extends Thread {    @Override    public void run() {        System.out.println(\"start new thread!\");    }}\n\n创建Thread实例时，传入一个Runnable实例\n  public class Main {    public static void main(String[] args) {        Thread t = new Thread(new MyRunnable());        t.start(); // 启动新线程    }}class MyRunnable implements Runnable {    @Override    public void run() {        System.out.println(\"start new thread!\");    }}\n\nlambda\n  public class Main {    public static void main(String[] args) {        Thread t = new Thread(() -&gt; {            System.out.println(\"start new thread!\");        });        t.start(); // 启动新线程    }}\n\n\n对线程设定优先级\n  Thread.setPriority(int n)// 1~10, 默认值5\n\n\n线程状态\n\n线程状态\nNew：新创建的线程，尚未执行\nRunnable：运行中的线程，正在执行run()方法的Java代码\nBlocked：运行中的线程，因为某些操作被阻塞而挂起\nWaiting：运行中的线程，因为某些操作在等待中\nTimed Waiting：运行中的线程，因为执行sleep()方法正在计时等待\nTerminated：线程已终止，因为run()方法执行完毕\n\n\n线程终止的原因有：\n线程正常终止：run()方法执行到return语句返回\n线程意外终止：run()方法因为未捕获的异常导致线程终止\n对某个线程的Thread实例调用stop()方法强制终止\n\n\n一个线程还可以等待另一个线程直到其运行结束\nmain线程在启动t线程后，通过t.join()等待t线程结束后再继续运行\n可以指定等待时间，超过等待时间线程仍然没有结束就不再等待\n对已经运行结束的线程调用join()方法会立刻返回\n\n\n\n\n中断线程\n\n在其他线程中对目标线程调用interrupt()方法，目标线程需要反复检测自身状态是否是interrupted状态，如果是，就立刻结束运行\nrunning标志位来标识线程是否应该继续运行\nHelloThread的标志位boolean running是一个线程间共享的变量\n线程间共享变量使用volatile关键字标记，确保每个线程都能读取到更新后的变量值\n  public class Main {    public static void main(String[] args)  throws InterruptedException {        HelloThread t = new HelloThread();        t.start();        Thread.sleep(1);        t.running = false; // 标志位置为false    }}class HelloThread extends Thread {    public volatile boolean running = true;    public void run() {        int n = 0;        while (running) {            n ++;            System.out.println(n + \" hello!\");        }        System.out.println(\"end!\");    }}\n\nvolatile关键字\n\n每次访问变量时，总是获取主内存的最新值\n每次修改变量后，立刻回写到主内存\n\n\n\n\n\n\n守护线程\n\n守护线程（Daemon Thread）\n守护线程是指为其他线程服务的线程\n调用start()方法前，调用setDaemon(true)把该线程标记为守护线程\n守护线程不能持有任何需要关闭的资源\n\n\n\n\n线程同步\n\n通过加锁和解锁的操作，就能保证3条指令总是在一个线程执行期间，不会有其他线程会进入此指令区间\n\n加锁和解锁之间的代码块我们称之为临界区（Critical Section），任何时候临界区最多只有一个线程能执行\n\nsynchronized关键字对一个对象进行加锁\n  synchronized(lock) {    n = n + 1;}\n\n找出修改共享变量的线程代码块\n选择一个共享实例作为锁\n使用synchronized(lockObject) { ... }\n\n\n无论是否有异常，都会在synchronized结束处正确释放锁\n\n不需要synchronized的操作\n\nJVM规范定义了几种原子操作\n基本类型（long和double除外）赋值，如：int n = m\n引用类型赋值，如：List&lt;String&gt; list = anotherList\n\n\n\n\n多行赋值语句，就必须保证是同步操作\n  classPoint {int x;int y;publicvoid set(int x,int y) {synchronized(this) {this.x = x;this.y = y;        }    }}\n\n写需要同步，读也需要同步\n\n\n不可变对象无需同步\n\n\n\n同步方法\n\nsynchronized逻辑封装\n  public class Counter {    private int count = 0;    public void add(int n) {        synchronized(this) {            count += n;        }    }    public void dec(int n) {        synchronized(this) {            count -= n;        }    }    public int get() {        return count;    }}// synchronized锁住的对象是this，即当前实例，使得创建多个Counter实例，互不影响，可以并发执行\n\n一个类被设计为允许多线程正确访问，我们就说这个类就是线程安全thread-safe\n\njava.lang.StringBuffer\n不变类，例如String，Integer，LocalDate\n类似Math这些只提供静态方法，没有成员变量的类\n\n\n锁住this实例=用synchronized修饰这个方法\n\nsynchronized修饰的方法就是同步方法，表示整个方法都必须用this实例加锁\n  public void add(int n) {    synchronized(this) { // 锁住this        count += n;    } // 解锁}public synchronized void add(int n) { // 锁住this    count += n;} // 解锁\n\n\nstatic方法添加synchronized，锁住的是该类的Class实例\n  publicclassCounter {publicstaticvoid test(int n) {synchronized(Counter.class) {            ...        }    }}\n\n\n死锁\n\n可重入锁\n同一个线程重复获取同一个锁，这种能被同一个线程反复获取的锁\n每获取一次锁记录+1，每退出synchronized块记录-1，减到0时释放锁\n\n\n死锁\n两个线程各自持有不同的锁，各自试图获取对方的锁，造成了双方无限等待下去\n死锁发生后，只能强制结束JVM进程\n线程获取锁的顺序要一致\n\n\n\n\n**wait**和**notify**\n\nwait\n\n线程协调运行\n\n当条件不满足时，线程进入等待状态\n当条件满足时，线程被唤醒继续执行任务\n\n\nwait()方法必须在当前获取的锁对象上调用，这里获取的是this锁\n  public synchronized String getTask() {\twhile (queue.isEmpty()) {\t\t\t// 释放this锁:      this.wait();      // 重新获取this锁  }\treturn queue.remove();}\n\n\nnotify\n\nwait()方法返回时需要重新获得this锁\n  public class Main {    public static void main(String[] args) throws InterruptedException {        var q = new TaskQueue();        var ts = new ArrayList&lt;Thread&gt;();        for (int i=0; i&lt;5; i++) {            var t = new Thread() {                public void run() {                    // 执行task:                    while (true) {                        try {                            String s = q.getTask();                            System.out.println(\"execute task: \" + s);                        } catch (InterruptedException e) {                            return;                        }                    }                }            };            t.start();            ts.add(t);        }        var add = new Thread(() -&gt; {            for (int i=0; i&lt;10; i++) {                // 放入task:                String s = \"t-\" + Math.random();                System.out.println(\"add task: \" + s);                q.addTask(s);                try { Thread.sleep(100); } catch(InterruptedException e) {}            }        });        add.start();        add.join();        Thread.sleep(100);        for (var t : ts) {            t.interrupt();        }    }}class TaskQueue {    Queue&lt;String&gt; queue = new LinkedList&lt;&gt;();    public synchronized void addTask(String s) {        this.queue.add(s);        this.notifyAll();    }    public synchronized String getTask() throws InterruptedException {        while (queue.isEmpty()) {            this.wait();        }        return queue.remove();    }}\n\n\n\n\nReentrantLock\n\njava.util.concurrent.locks包\n提供的ReentrantLock用于替代synchronized加锁\nReentrantLock是可重入锁\n和synchronized一样，一个线程可以多次获取同一个锁\n和synchronized不同的是，ReentrantLock可以尝试获取锁\n\n\n\n\n\n\nCondition\n\nCondition对象\n来实现ReentrantLock和wait、notify\n\n使用Condition\n\n引用的Condition对象必须从Lock实例的newCondition()返回，获得一个绑定Lock实例的Condition实例\n\n  class TaskQueue {    private final Lock lock = new ReentrantLock();    private final Condition condition = lock.newCondition();    private Queue&lt;String&gt; queue = new LinkedList&lt;&gt;();    public void addTask(String s) {        lock.lock();        try {            queue.add(s);            condition.signalAll();        } finally {            lock.unlock();        }    }    public String getTask() {        lock.lock();        try {            while (queue.isEmpty()) {                condition.await();            }            return queue.remove();        } finally {            lock.unlock();        }    }}\n\nCondition提供的await()、signal()、signalAll()\n\nsynchronized锁对象的wait()、notify()、notifyAll()\nawait()会释放当前锁，进入等待状态\nsignal()会唤醒某个等待线程\nsignalAll()会唤醒所有等待线程\n唤醒线程从await()返回后需要重新获得锁\n\n\n\n\n\n\nReadWriteLock\n\nReadWriteLock\n只允许一个线程写入（其他线程既不能写入也不能读取）\n没有写入时，多个线程允许同时读（提高性能）\n\n\nStampedLock\n\n读的过程中也允许获取写锁后写入\n\n\nSemaphore\n\n保证同一时间最多N个线程访问受限资源\n\n\n**Concurrent**集合\n\njava.util.concurrent包也提供了对应的并发集合类\n\n\n\ninterface\nnon-thread-safe\nthread-safe\n\n\n\nList\nArrayList\nCopyOnWriteArrayList\n\n\nMap\nHashMap\nConcurrentHashMap\n\n\nSet\nHashSet / TreeSet\nCopyOnWriteArraySet\n\n\nQueue\nArrayDeque / LinkedList\nArrayBlockingQueue / LinkedBlockingQueue\n\n\nDeque\nArrayDeque / LinkedList\nLinkedBlockingDeque\n\n\n\n\n\nAtomic\n\nAtomic类是通过无锁（lock-free）的方式实现的线程安全（thread-safe）访问\njava.util.concurrent.atomic提供的原子操作可以简化多线程编程\n原子操作实现了无锁的线程安全\n适用于计数器，累加器等\n\n\n\n\n线程池\n\n线程池：接收大量小任务并进行分发处理\n\nExecutorService接口表示线程池\n  // 创建固定大小的线程池:ExecutorService executor = Executors.newFixedThreadPool(3);// 提交任务:executor.submit(task1);executor.submit(task2);executor.submit(task3);executor.submit(task4);executor.submit(task5);\n\n常用实现类\n\nFixedThreadPool：线程数固定的线程池\nCachedThreadPool：线程数根据任务动态调整的线程池\nSingleThreadExecutor：仅单线程执行的线程池\n\n\n\n\nScheduledThreadPool\n\n定期反复执行\n\n\n\n\n**Future**\n\n对线程池提交一个Callable任务，可以获得一个Future对象\n可以用Future在将来某个时刻获取结果\n\n\n**CompletableFuture**\n\n可以指定异步处理流程\nthenAccept()处理正常结果\nexceptional()处理异常结果\nthenApplyAsync()用于串行化另一个CompletableFuture\nanyOf()和allOf()用于并行化多个CompletableFuture\n\n\n\n\nForkJoin\n\nFork/Join线程池：把一个大任务拆成多个小任务并行执行\n基于“分治”的算法：通过分解任务，并行执行，最后合并结果得到最终结果\nForkJoinPool线程池可以把一个大任务分拆成小任务并行执行，任务类必须继承自RecursiveTask或RecursiveAction\n使用Fork/Join模式可以进行并行计算以提高效率\n\n\nThreadLocal\n\nThreadLocal\n表示线程的“局部变量”，确保每个线程的ThreadLocal变量都是各自独立的\n适合在一个线程的处理流程中保持上下文（避免同一参数在所有方法中传递）\n使用ThreadLocal要用try ... finally结构，并在finally中清除\n\n\n\n\n虚拟线程\n\n为了解决IO密集型任务的吞吐量，它可以高效通过少数线程去调度大量虚拟线程\n\n\n\n函数式编程\n**Lambda**基础\n函数式编程\n\nFunctional Programming把函数作为基本运算单元、变量，可以接收函数、返回函数\n\n\nLambda表达式\n\n调用Arrays.sort()时传入一个Comparator实例\n  import java.util.Arrays;public class Main {    public static void main(String[] args) {        String[] array = new String[] { \"Apple\", \"Orange\", \"Banana\", \"Lemon\" };        Arrays.sort(array, (s1, s2) -&gt; {            return s1.compareTo(s2);        });        System.out.println(String.join(\", \", array));    }}\n\nLambda表达式\n  (s1, s2) -&gt; {return s1.compareTo(s2);}\n\n参数是(s1, s2)\n-&gt; { ... }表示方法体\n参数类型可以省略，编译器自动推断出String类型\n\n\n单方法接口，即一个接口只定义了一个方法，如Comparator\n\n定义了单方法的接口称之为FunctionalInterface，用注解@FunctionalInterface标记\n\nCallable接口\n  @FunctionalInterfacepublic interfaceCallable&lt;V&gt; {    V call()throws Exception;}\n\nComparator接口\n  @FunctionalInterfacepublic interface Comparator&lt;T&gt; {    int compare(T o1, T o2);    boolean equals(Object obj);    default Comparator&lt;T&gt; reversed() {        return Collections.reverseOrder(this);    }    default Comparator&lt;T&gt; thenComparing(Comparator&lt;? super T&gt; other) {        ...    }    ...}\n\nComparator接口只有一个抽象方法int compare(T o1, T o2)\n其他的方法都是default方法或static方法\nboolean equals(Object obj)是Object定义的方法，不算在接口方法内\n因此，Comparator也是一个FunctionalInterface\n\n\n\n\n\n\n方法引用\n指如果某个方法签名和接口恰好一致，就可以直接传入方法引用\n\n在Arrays.sort()中直接传入了静态方法cmp的引用，用Main::cmp表示\n  import java.util.Arrays;public class Main {    public static void main(String[] args) {        String[] array = new String[] { \"Apple\", \"Orange\", \"Banana\", \"Lemon\" };        Arrays.sort(array, Main::cmp);        System.out.println(String.join(\", \", array));    }    static int cmp(String s1, String s2) {        return s1.compareTo(s2);    }}\n\n引用实例方法\n  import java.util.Arrays;public class Main {    public static void main(String[] args) {        String[] array = new String[] { \"Apple\", \"Orange\", \"Banana\", \"Lemon\" };        Arrays.sort(array, String::compareTo);        System.out.println(String.join(\", \", array));    }}\n\n其中，String.compareTo()实例方法\n  public final class String {    public int compareTo(String o) {        ...    }}// String类的compareTo()方法在实际调用的时候，第一个隐含参数总是传入this，相当于静态方法：public static int compareTo(String this, String o);\n\n\n引用构造方法\n  import java.util.*;import java.util.stream.*;public class Main {    public static void main(String[] args) {        List&lt;String&gt; names = List.of(\"Bob\", \"Alice\", \"Tim\");        List&lt;Person&gt; persons = names.stream().map(Person::new).collect(Collectors.toList());        System.out.println(persons);    }}class Person {    String name;    public Person(String name) {        this.name = name;    }    public String toString() {        return \"Person:\" + this.name;    }}\n\n\nFunctionalInterface\n\n不强制继承关系，不需要方法名称相同\n方法参数（类型和数量）与方法返回类型相同，即认为方法签名相同\n\n\n\n\n使用**Stream**\nStream API\n\n位于java.util.stream包，代表的是任意Java对象的序列\n\n不同于java.io\n\n\n\njava.io\njava.util.stream\n\n\n\n存储\n顺序读写的byte或char\n\n\n用途\n序列化至文件或网络\n\n\n\nList是操作一组已存在的Java对象，而Stream实现的是惰性计算\n\n\n\n\njava.util.List\njava.util.stream\n\n\n\n元素\n已分配并存储在内存\n可能未分配，实时计算\n\n\n用途\n操作一组已存在的Java对象\n惰性计算\n\n\n\n可以“存储”有限个或无限个元素\n\n转换为另一个Stream，而不是修改原Stream本身（只存储了转换规则）\n\n惰性计算\n  Stream&lt;BigInteger&gt; naturals = createNaturalStream(); // 不计算Stream&lt;BigInteger&gt; s2 = naturals.map(BigInteger::multiply); // 不计算Stream&lt;BigInteger&gt; s3 = s2.limit(100); // 不计算s3.forEach(System.out::println); // 计算\n\n链式\n  int result = createNaturalStream() // 创建Stream             .filter(n -&gt; n % 2 == 0) // 任意个转换             .map(n -&gt; n * n) // 任意个转换             .limit(100) // 任意个转换             .sum(); // 最终计算结果\n\n\n创建**Stream**\n\nStream.of()\n\nStream&lt;String&gt; stream = Stream.of(\"A\", \"B\", \"C\", \"D\");\n\n\n基于数组或Collection\n  import java.util.*;import java.util.stream.*;public class Main {    public static void main(String[] args) {        // 数组Arrays.stream()\t\t\t\tStream&lt;String&gt; stream1 = Arrays.stream(new String[] { \"A\", \"B\", \"C\" });        //Collection调用stream()\t\t\t\tStream&lt;String&gt; stream2 = List.of(\"X\", \"Y\", \"Z\").stream();        stream1.forEach(System.out::println);        stream2.forEach(System.out::println);    }}\n\n基于Supplier\n\nStream.generate()方法，传入一个Supplier对象\n  import java.util.function.*;import java.util.stream.*;public class Main {    public static void main(String[] args) {        Stream&lt;Integer&gt; natual = Stream.generate(new NatualSupplier());        // 无限序列必须先变成有限序列再打印        natual.limit(20).forEach(System.out::println);    }}class NatualSupplier implements Supplier&lt;Integer&gt; {    int n = 0;    public Integer get() {        n++;        return n;    }}\n\n\n其他\n\nFiles类的lines()方法把一个文件变成一个Stream，每个元素代表文件一行内容\n正则表达式的Pattern对象有一个splitAsStream()方法，把一个长字符串分割成Stream序列而不是数组\n\n\n基本类型\n\nIntStream、LongStream和DoubleStream\n使用基本类型的Stream，目的是提高运行效率\n  // 将int[]数组变为IntStream:IntStream is = Arrays.stream(newint[] { 1, 2, 3 });// 将Stream&lt;String&gt;转换为LongStream:LongStream ls = List.of(\"1\", \"2\", \"3\").stream().mapToLong(Long::parseLong);\n\n\n\n\n\n\n使用**map**\n\nStream.map()\n\nmap()方法接收的对象是Function接口对象\n\n它定义了一个apply()方法，负责把一个T类型转换成R类型：\n  &lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper);\n\n其中，Function的定义\n  @FunctionalInterfacepublicinterfaceFunction&lt;T,R&gt; {// 将T类型转换为R:    R apply(T t);}\n\n\n数学计算、字符串操作、任何Java对象\n  import java.util.*;import java.util.stream.*;public class Main {    public static void main(String[] args) {        List.of(\"  Apple \", \" pear \", \" ORANGE\", \" BaNaNa \")                .stream()                .map(String::trim) // 去空格                .map(String::toLowerCase) // 变小写                .forEach(System.out::println); // 打印    }}\n\n\nStream.filter()\n\nfilter()方法接收的对象是Predicate接口对象，它定义了一个test()方法，负责判断元素是否符合条件\n  @FunctionalInterfacepublicinterfacePredicate&lt;T&gt; {// 判断元素t是否符合条件:boolean test(T t);}\n\n常用于数值、任何Java对象\n\n从一组给定的LocalDate中过滤掉工作日，以便得到休息日\n\n  import java.time.*;import java.util.function.*;import java.util.stream.*;public class Main {    public static void main(String[] args) {        Stream.generate(new LocalDateSupplier())                .limit(31)                .filter(ldt -&gt; ldt.getDayOfWeek() == DayOfWeek.SATURDAY || ldt.getDayOfWeek() == DayOfWeek.SUNDAY)                .forEach(System.out::println);    }}class LocalDateSupplier implements Supplier&lt;LocalDate&gt; {    LocalDate start = LocalDate.of(2020, 1, 1);    int n = -1;    public LocalDate get() {        n++;        return start.plusDays(n);    }}\n\n\n\n\n使用**reduce**\n\nStream.reduce()\nmap()和filter()都是Stream的转换方法\n\nStream.reduce()则是Stream的一个聚合方法，把一个Stream的所有元素按照聚合函数聚合成一个结果\n\n聚合方法会立刻对Stream进行计算，对一个Stream做聚合计算后，结果就不是一个Stream，而是一个其他的Java对象\n\nreduce()方法传入的对象是BinaryOperator接口，它定义了一个apply()方法，负责把上次累加的结果和本次的元素进行运算，并返回累加的结果\n  @FunctionalInterfacepublicinterfaceBinaryOperator&lt;T&gt; {// Bi操作：两个输入，一个输出    T apply(T t, T u);}\n\n\n\n\n输出集合\n\n输出为List\n\n调用collect()并传入Collectors.toList()对象\n实际上是一个Collector实例，通过类似reduce()的操作，把每个元素添加到一个收集器中（实际上是ArrayList）\n  import java.util.*;import java.util.stream.*;public class Main {    public static void main(String[] args) {        Stream&lt;String&gt; stream = Stream.of(\"Apple\", \"\", null, \"Pear\", \"  \", \"Orange\");        List&lt;String&gt; list = stream.filter(s -&gt; s != null &amp;&amp; !s.isBlank()).collect(Collectors.toList());        System.out.println(list);    }}\n\n\n\n\n输出为数组\n\n调用toArray()方法，并传入数组的“构造方法”\n  List&lt;String&gt; list = List.of(\"Apple\", \"Banana\", \"Orange\");String[] array = list.stream().toArray(String[]::new);// 构造方法是String[]::new，签名实际上是IntFunction&lt;String[]&gt;定义的String[] apply(int)// 即传入int参数，获得String[]数组的返回值\n\n\n输出为Map\n\n指定两个映射函数，分别把元素映射为key和value\n  import java.util.*;import java.util.stream.*;public class Main {    public static void main(String[] args) {        Stream&lt;String&gt; stream = Stream.of(\"APPL:Apple\", \"MSFT:Microsoft\");        Map&lt;String, String&gt; map = stream                .collect(Collectors.toMap(                        // 把元素s映射为key:                        s -&gt; s.substring(0, s.indexOf(':')),                        // 把元素s映射为value:                        s -&gt; s.substring(s.indexOf(':') + 1)));        System.out.println(map);    }}\n\n\n分组输出\n\nCollectors.groupingBy()提供两个函数\n\n一分组的key，这里使用s -&gt; s.substring(0, 1)，表示只要首字母相同的String分到一组\n分组的value，这里直接使用Collectors.toList()，表示输出为List\n\n  import java.util.*;import java.util.stream.*;public class Main {    public static void main(String[] args) {        List&lt;String&gt; list = List.of(\"Apple\", \"Banana\", \"Blackberry\", \"Coconut\", \"Avocado\", \"Cherry\", \"Apricots\");        Map&lt;String, List&lt;String&gt;&gt; groups = list.stream()                .collect(Collectors.groupingBy(s -&gt; s.substring(0, 1), Collectors.toList()));        System.out.println(groups);    }}\n\n\n\n\n其他\n\n排序\n\n调用sorted()方法，要求Stream的每个元素必须实现Comparable接口\n\n如果要自定义排序，传入指定的Comparator\n  List&lt;String&gt; list = List.of(\"Orange\", \"apple\", \"Banana\")    .stream()    .sorted(String::compareToIgnoreCase)    .collect(Collectors.toList());\n\nsorted()只是一个转换操作，它会返回一个新的Stream\n\n\n\n去重\n\ndistinct()\n  List.of(\"A\", \"B\", \"A\", \"C\", \"B\", \"D\")    .stream()    .distinct()    .collect(Collectors.toList());// [A, B, C, D]\n\n\n截取\n\n截取操作常用于把一个无限的Stream转换成有限的Stream\nskip()用于跳过当前Stream的前N个元素\n\nlimit()用于截取当前Stream最多前N个元素\n  List.of(\"A\", \"B\", \"C\", \"D\", \"E\", \"F\")    .stream()    .skip(2)// 跳过A, B    .limit(3)// 截取C, D, E    .collect(Collectors.toList());// [C, D, E]\n\n截取操作也是一个转换操作，将返回新的Stream\n\n\n\n\n\n合并\n\n将两个Stream合并为一个Stream使用Stream静态方法concat()\n  Stream&lt;String&gt; s1 = List.of(\"A\", \"B\", \"C\").stream();Stream&lt;String&gt; s2 = List.of(\"D\", \"E\").stream();// 合并:Stream&lt;String&gt; s = Stream.concat(s1, s2);System.out.println(s.collect(Collectors.toList())); // [A, B, C, D, E]\n\n\nflatMap\n\nStream转换为Stream&lt;Integer&gt;，使用flatMap()\n  Stream&lt;Integer&gt; i = s.flatMap(list -&gt; list.stream());\n\n把Stream的每个元素（这里是List）映射为Stream，合并成一个新Stream\n\n\n\n并行\n  Stream&lt;String&gt; s = ...String[] result = s.parallel() // 变成一个可以并行处理的Stream                   .sorted() // 可以进行并行排序                   .toArray(String[]::new);\n\n其他聚合方法\n\n除了reduce()和collect()外\ncount()：用于返回元素个数\nmax(Comparator&lt;? super T&gt; cp)：找出最大元素\nmin(Comparator&lt;? super T&gt; cp)：找出最小元素\n\n\n针对IntStream、LongStream和DoubleStream\nsum()：对所有元素求和\naverage()：对所有元素求平均数\n\n\n用来测试Stream的元素是否满足以下条件\nboolean allMatch(Predicate&lt;? super T&gt;)：是否所有元素均满足测试条件\nboolean anyMatch(Predicate&lt;? super T&gt;)：是否至少一个元素满足测试条件\n\n\nforEach()\n循环处理Stream的每个元素，System.out::println打印Stream的元素\n\n\n\n\n\n\n\n\n\n","categories":["Note"],"tags":["OR","Java","Algorithm"]},{"title":"Simulation","url":"/2023/07/18/Simulation/","content":"Intro\n\nSimulation\n\n类型：智能体仿真（ABM）、离散事件仿真(DES)、系统动力学(SD）\n\n优势\n\n城市交通\n  \n\n制造业\n\n产品设计\n  \n\n管理系统\n\n示例\n  \n  \n\n\n\n\n\n\n\n为什么要进行建模仿真？ \n\n\n\n官网（中文 、英文 ）\n\nCloud \n\nHelp \n\nJava \nSearch \nEngine \n\n\nJava相关 \n  Stack overflow  (中文社区 )\n\n\n\n\nShip check model\n模型\n软件-欢迎页面\n  \n\n软件界面\n\n入门课程 \n\nBig book \n\nResource\n\nBook \nPaper \n\n\n库\n  \n\n\n\n船舶过闸安检逻辑模型\n\n逻辑界面\n  \n\n示例\n\n属性面板\n  \n\n时间计算\n  agent.timeStart=time();timeStay=time()-agent.timeStart;\n\n优先级示例\n  class RandomSelector {    public int select(int[] nums, double[] probs) {        if (nums == null || nums.length == 0 || probs == null || probs.length == 0 || nums.length != probs.length) {            throw new IllegalArgumentException(\"Invalid input\");        }        double cumProb = 0.0;        Random rand = new Random();        double probSelect = rand.nextDouble() * Arrays.stream(probs).sum();        for (int i = 0; i &lt; nums.length; i++) {            cumProb += probs[i];            if (probSelect &lt;= cumProb) {                return nums[i];            }        }        return nums[nums.length - 1];    }}int[] nums = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};double[] probs = {0.67, 0.1, 0.05, 0.04, 0.04, 0.03, 0.02, 0.02, 0.01, 0.01, 0.01};RandomSelector generator = new RandomSelector();int priority = generator.select(nums, probs);return priority;\n\n拓展示例\n\n自定义环境 \nSB3 \nAlpyne \n\n\n\n\n\n\n\n\n\nSummary\n如何建立自己的模型\n明确研究问题\n熟悉Anylogic软件操作\n跟随教程搭建初始的基础模型\n拓展/添加个性化属性\nBug? Need help?\nCheck\nAsk: 人 / 机\n\n\n\n\n\n","categories":["Note"],"tags":["Simulation"]},{"title":"Statistics","url":"/2023/12/28/Statistics/","content":"Statistics第一章 统计与数据一、 统计及应用领域\n统计的含义\n统计学是收集、处理、分析、解释数据并从数据中得出结论的科学\n统计工作\n指收集、整理和分析统计数据，并探索数据的内在数量规律性的活动过程\n\n\n统计数据\n即统计工作过程所获得的各种数据资料和其他资料的统称。表现为各种反映社会经济现象数量特征的原始记录、统计台账、统计表、统计图、统计分析报告、政府统计公报、统计年鉴等各种数据和文字资料\n\n\n统计学\n指阐述统计工作基本理论和基本方法和科学，是对统计工作实践的理论概括和经验总结。以现象总体的数量方面为研究对象，阐明统计设计、统计调查、统计整理和分析的理论和方法\n\n\n\n\n统计的特点\n数量性\n数量特征\n数量关系\n数量界限\n\n\n总体性\n具体性\n\n\n统计学的类型\n方法功能\n描述统计学\n数据收集、处理、汇总、图表描述、概括与分析等统计方法\n\n\n推断统计学\n研究如何利用样本数据来推断总体特征的统计方法\n\n\n\n\n研究重点\n理论统计学\n应用统计学\n\n\n\n\n应用领域\n企业发展战略\n产品质量管理\n市场研究\n财务分析\n经济预测\n人力资源管理\n\n\n\n二、数据类型\n计量尺度\n定类\n分类尺度\n可指定数字代码\n穷尽、互斥\n等于不等\n\n\n定序\n顺序尺度（分类同时排序）\n无准确差值\n等于不等大于小于\n\n\n定距\n间隔尺度\n数值\n无绝对零点\n等于不等大于小于加减\n\n\n定比\n比率尺度\n数值\n有绝对零点\n等于不等大于小于加减乘除\n\n\n\n\n数据类型\n分类数据、数值型数据\n分类数据：归于某一类别的非数字性数据\n有序分类数据（顺序数据）：归于某一有序类别的非数字性数据\n\n\n数值型数据：按定距和定比计量尺度测量的观察值\n定性数据、定量数据\n定性数据（品质数据）：无序、有序分类数据\n定量数据（数量数据）：数值型数据\n\n\n\n\n观测数据、实验数据\n观测数据：通过调查或观测收集到的数据\n实验数据：在实验中控制实验对象收集到的数据\n\n\n截面数据、时间序列数据\n截面数据\n指在相同或近似相同的时点上采集的数据\n通常在不同空间获得的，用于描述现象在某一时刻的变化情况\n\n\n时间序列数据\n指在不同时间上采集到的数据集合\n通常按时间顺序收集，用于描述要素随时间变化的情况\n\n\n\n\n\n\n数值型数据的的表现形式\n绝对数\n反映统计研究对象某一方面绝对数量\n用来描述研究对象的规模大小和水平高低\n时期数、时点数\n时期数：反映研究对象在某一段时间内累计发生的数值总量\n时点数：反映研究对象在某个时点上所表现的数值总量\n\n\n\n\n相对数\n由两个相互联系的数值相除而得出的比率\n反映了研究对象内部各部分之间或现象之间的相互关系\n数值表现：无名数、有名数\n种类\n结构相对数\n比较相对数\n动态相对数\n强度相对数\n计划完成程度相对数\n\n\n\n\n平均数\n表现同类现象某一数字变量值的一般水平\n静态平均数\n同一时间同类现象的一般水平\n\n\n动态平均数\n不同时间同类现象的一般水平\n\n\n\n\n\n\n\n三、统计学基本要素\n总体、个体和样本\n总体\n构成统计活动研究对象的全部事物所组成的整体\n\n\n个体\n总体中的每个个体事物\n\n\n总体容量\n总体中全部个事物的数量\n有限总体和无限总体\n\n\n样本\n指从总体中随机抽取出来，并作为其代表的那一部分个体所组成的子集\n构成样本的个体数量称为样本容量\n样本特点\n每个个体取自总体内部\n样本具有不唯一性\n样本是总体的代表\n样本抽取具有随机性\n\n\n\n\n\n\n参数与统计量\n参数\n用来描述总体特征的概括性数字度量\n总体参数\n总体均值\n总体标准差\n总体比例\n\n\n\n\n统计量\n用来描述样本特征的概括性数字度量\n样本统计量\n样本均值\n样本标准差\n样本比例\n\n\n\n\n\n\n变量与变量值\n变量\n指对客观现象特征描述的概念，客观现象的特征取值或类别在一个以上者\n数字变量\n属性变量\n\n\n\n\n变量值\n指变量的具体表现\n\n\n变量特征\n变量是用于描述总体或个体特征的名称\n一个变量具有多个变量值，不是一一对应\n不同时间取值、不同空间取值\n\n\n变量分类\n分类变量、数值变量\n反映特征：属性变量、数字变量\n取值连续：离散变量、连续变量\n确定性：确定性变量、随机变量\n因果关系：自变量、因变量\n研究对象体系范围：内生变量、外生变量\n客观性：实在变量、虚拟变量\n\n\n\n\n\n习题参考答案 第二章 数据的搜集一、数据的来源\n统计数据的直接来源\n观察\n实验\n调查\n组织方式\n普查\n抽样调查\n统计报表\n重点调查\n典型调查\n\n\n\n\n\n\n统计数据的间接来源\n与研究内容相关的原信息已经存在，对其进行重新加工、整理，使之成为统计分析可以使用的数据\n搜集容易、成本低；一定的局限性\n\n\n\n二、调查方法\n概率抽样和非概率抽样\n概率抽样\n即随机抽样，指遵循随即原则进行的抽样，总体中每个单位都有一定的机会被选入样本\n抽样按照一定的概率以随即原则抽取样本\n每个单位被抽中的概率是已知的\n样本估计总体时，考虑到每个样本单位被抽中的概率\n包括等概率抽样和不等概率抽样\n\n\n概率抽样方式\n简单随机抽样\n分层抽样\n整群抽样\n系统抽样\n多阶段抽样\n\n\n优点\n可以依据调查结果计算估计量误差，得到对总体目标量推断的可靠程度\n\n\n\n\n非概率抽样\n相对于概率抽样，指抽取样本时不依据随机原则，而根据研究目的对数据的要求，采用某种方式从总体中抽出部分单位对其实施调查\n方式\n方便抽样\n判断抽样\n自愿样本\n滚雪球抽样\n配额抽样\n\n\n\n\n\n\n搜集数据的基本方法\n自填式\n\n面访式\n\n电话式\n\n选择对比\n  \n\n\n\n\n三、实验方法\n实验组和对照组\n实验组\n随机抽选的实验对象子集，子集中每个单位接受某种特别的处理\n\n\n对照组\n每个单位不接受实验组成员的特别处理\n\n\n\n\n问题\n人的意愿\n心理问题\n道德问题\n\n\n实验中的统计\n\n四、数据的误差\n抽样误差\n抽样的随机性引起的样本结果与总体真值之间的差异\n\n\n非抽样误差\n除抽样误差之外的有其他原因引起的样本观测结果与总体真值之间的差异\n抽样框误差\n回答误差\n无回答误差\n调查员误差\n测量误差\n\n\n\n\n误差的控制\n\n习题参考答案 第三章 数据的图表展示一、数据的预处理\n数据的预处理\n是在数据分析前所做的必要处理，包括数据审核、筛选、排序等\n\n\n数据审核\n对于通过调查得到的原始数据，从完整性和准确性两方面审核\n完整性\n检查调查个体是否有遗漏，调查项目是否填写齐全\n\n\n准确性\n检查数据是否有错误，是否存在异常值\n\n\n\n\n二手数据，检查适用性和时效性\n\n\n数据筛选\n根据需要找出符合特定条件的某类数据\n\n\n数据排序\n按一定顺序将数据排列，以便浏览数据发现明显的特征或趋势\n\n\n\n二、分类数据的整理与展示\n分类数据的整理\n列出类别，计算每一类别的频数频率或比例比率\n频数：落在某一特定类别或组中的数据个数\n频数分布：用表格形式表现出各个类别及落在其中的相应频数\n例如\n简单频数表：一个分类变量\n列联表、交叉表：两个分类变量\n\n\n\n\n\n\n分类数据的图示\n条形图和帕累托图\n条形图：条形的高度或长度来表示数据多少（柱状图）\n帕累托图：按各类别出现的频数多少排序后的条形图\n\n\n饼图和环形图\n饼图：用圆形和圆内扇形的度数来表示数值大小的图形，用于数据占比\n环形图：用于两个或多个分类变量的构成\n\n\n\n\n\n三、数据的整理与展示\n数据分组\n根据统计研究需求将原始数据按照某种分类标准分成不同的组别\n确定组数\n各组组距\n分组制作频数分布表\n\n\n\n\n数值数据的图示\n直方图\n矩形的宽高（面积）表示数据频数分布，横轴表示数据分组，纵轴表示频数频率\n\n\n箱型图\n不仅反映数据分布的特征，还可以对多组数据进行比较\n\n\n散点图\n展示两个数值变量之间关系的图\n\n\n雷达图\n显示多个变量的图示\n\n\n\n\n\n习题参考答案 第四章 数据的概括性度量一、集中趋势的度量\n集中趋势\n指一组数据向某一中心值靠拢的程度，反映了一组数据中心点的所在\n\n\n平均数\n均值\n一组数据相加后除以数据个数得到的结果\n简单平均数\n加权平均数\n\n\n\n\n中位数和四分位数\n中位数\n一组数据排序后处在中间位置的数值\n\n\n四分位数\n一组数据排序后处于25%和75%位置上的数值\n\n\n\n\n众数\n一组数据中出现频数最多的数值\n\n\n几何平均数\nn个变量值乘积的n次方根\n\n\n\n二、离散程度的度量\n全距和四分卫距\n全距\n是一组数据最大值与最小值之差，极差\n\n\n四分卫距\n是一组数据75%与25%位置上的四分位数据之差\n\n\n\n\n方差与标准差\n一组数据中每个数据与其平均数离差\n平均差：取绝对值，求和后的平均数\n方差：平方后再求平均数\n标准差：方差开方后的结果\n\n\n\n\n离散系数\n变异系数，是一组数据的标准差与其相应的平均数之比，用于比较不同样本的离散程度\n\n\n标准分数\n是某个数据与其平均数的离差除以标准差后的值\n\n\n\n三、分布形状的度量\n偏度系数\n指数据分布的不对称性\n\n数据分布对称，偏度系数等于0\n\n\n\n\n峰度系数\n指数据分布峰值的高低\n\n\n\n\n第五章 概率与概率分布一、随机事件及其概率\n基本概念\n随机事件\n在同一组条件下，每次实验可能出现也可能不出现的事件，偶然事件\n\n\n必然事件\n在同一组条件下，每次一定出现的事件\n\n\n不可能事件\n在同一组条件下，每次一定不出现的事件\n\n\n基本事件\n一个事件不能分解为两个或多个事件\n一次实验中只能观察到有且仅有一个基本事件\n\n\n样本空间\n一次实验中所有基本事件的全体称为样本空间或基本空间\n\n\n\n\n事件的概率\n事件的概率是对事件在实验中出现的可能性大小的一种度量，记事件出现可能性大小的数值为\n概率\n古典定义：某一随机试验结果有限，且各个结果出现的可能性相等，则某一事件发生的概率称为该事件所包含的基本事件个数与样本空间所包含的基本事件个数的比值记为\n统计定义：在相同条件下随机试验次，某事件A出现次，则比值称为事件发生的频率。随着的增大，该频率围绕某一常常数上下波动，且波动幅度逐渐减小趋于稳定，此频率稳定值即为改事件的概率，记为\n主观定义\n\n\n\n\n\n二、离散型随机变量及其分布\n随机变量\n随机事件的数量化\n采用数量标识表示\n\n\n随机变量定义\n同一组条件下每次实验可能出现的结果都能列举出来，即的所有可能值具有确定概率，其中，，称为概率函数，称为的随机变量，为随机变量的概率函数\n\n\n两种类型的随机变量\n离散型随机变量\n随机变量的所有取值都可以逐个列举出来\n\n\n连续性随机变量\n随机变量的所有取值都不能逐个列举出来\n\n\n\n\n\n\n离散型随机变量的概率分布\n随机变量的概率分布\n, 且\n0-1分布，均匀分布\n\n\n离散型随机变量的期望值和方差\n期望值\n在离散型随机变量的一切可能值的完备组中，各可能值与其对应概率的乘积之和称为该随机变量的期望值(数学期望)，记为或\n\n\n方差与标准差\n方差\n反映随机变量取值的离散程度，每个随机变量取值与期望值离差的平方后期望值\n\n离散型随机变量：\n简化：\n标准差\n\n\n\n离散系数\n比较不同期望值总体之间的离散趋势：\n\n\n\n\n二项分布和泊松分布\n二项分布\n特征\n个相同的试验，试验相互独立，试验结果对应于一个离散型随机变量\n每次试验只有两个可能的结果，且对于概率、相同，\n\n\n重Bernoulli trials（贝努里试验）\n表示次重复独立试验中事件出现的次数\n, \n且\n\n\n\n\n服从二项分布，记为\n其中，\n二项分布期望值，方差\n当时，二项分布转化为0-1分布：，\n\n\n\n\n泊松分布\n用来描述指定时间范围内或在指定面积体积内某一事件出现的次数分布\n, \n为给定时间间隔事件的平均数\n泊松分布期望值\n重Bernoulli trials（贝努里试验）当p→0时，试验次数很大忙，二项分布近似于泊松分布，即\n\n\n\n\n\n\n\n三、连续性随机变量的概率分布\n概率密度与分布函数\n概率密度函数来表示连续性随机变量\n\n\n\n随机变量在之间的概率\n\n\n分布函数表示连续性随机变量的概率\n\n\n\n\n分布函数的导数是连续性随机变量的概率密度\n\n连续性随机变量期望值与方差\n\n\n\n\n\n\n\n\n正态分布\n具有钟形概率分布的随机变量，正态随机变量，相应的概率分布称为正态分布\n概率密度\n, , 记为\n, \n, 曲线关于对称, 且此处最大：\n\n\n标准正态分布\n, , \n概率密度函数\n\n\n\n分布函数\n\n\n\n\n\n线性转化\n → \n\n\n正态分布表\n\n\n\n\n\n\n第六章 统计量及其抽样分布一、统计量\n统计量的概念\n概念\n设是总体中抽取的容量为的一个样本，由此样本构造一个函数, 不依赖于任何未知参数，则称函数是一个统计量/样本统计量\n当获得样本一组具体观测值时，代入，计算出的数值，得到一个具体的统计量值\n\n\n\n\n常用统计量\n样本均值\n样本方差\n样本变异系数\n样本k阶矩\n样本k阶中心矩\n样本偏度\n样本峰度\n\n\n\n二、正态分布导出的重要分布\n抽样分布\n总体X的分布类型已知时，若对任意自然数n都能导出统计量分布的数学表达式，称为精确的抽样分布\n正态总体条件下，统计三大分布：分布，分布，分布\n\n\n分布\n设随机变量相互独立，且服从标准正态分布，则它们的平方和服从自由度为n的分布\n自由度：独立变量的个数 / 二次型的秩\n\n\n数学期望：, 方差：\n具有可加性：, , 则\n时，分布的极限分布是正态分布\n\n\n分布\n设随机变量, , 和独立\n, 记为, 为自由度\n时，数学期望; 时，方差\n柯西分布：自由度为1；时，分布的密度函数越接近标准正态分布\n设来自正态分布的一个样本\n, \n\n\n\n\n; \n, , , \n\n\n\n\n\n\n分布\n随机变量、相互独立，且, \n随机变量\n称服第一自由度为，第二自由度为的分布，记为\n数学期望, 方差\n分布的分位数\n\n\n随机变量服从分布，则服从分布\n\n\n\n三、样本均值的分布和中心极限定理\n抽样分布\n设为某一总体中抽出的随机样本，独立同分布\n当总体分布为正态分布时\n的抽样分布仍为正态分布，\n的期望值与总体均值相同，方差缩小为总体方差的\n\n\n\n\n无偏性：用样本均值去估计总体均值时，平均没有误差\n无论总体是什么分布，设总体均值为，总体方差为\n\n\n\n\n当比较大时，近似服从\n有\n\n\n\n\n\n\n中心极限定理\n设从均值，方差（有限）的任意一个总体中抽取样本量为的样本，充分大时，样本均值的抽样分布近似服从的正态分布\n\n\n\n第七章 参数估计一、参数估计的基本原理\n估计量与估计值\n\n参数估计是用样本统计量去估计总体参数\n估计总体参数的统计量称为估计量\n如：样本均值、比例、方差\n根据具体样本计算出的估计量的数值称为估计值\n\n\n\n\n\n\n点估计和区间估计\n\n点估计\n用样本统计量的某个取值直接作为总体参数的估计值\n围绕点估计值构造总体参数的一个区间\n\n\n区间估计\n在点估计的基础上给出总体参数估计的一个区间范围，通常由样本统计量加减估计误差\n\n由样本统计量所构造的总体参数的估计区间称为置信区间\n\n最小值置信下限，最大值置信上限\n\n置信区间\n  \n\n\n\n构造置信区间步骤重复多次，置信区间包含总体参数真值次数所占的比例称为置信水平/置信度/置信系数\n\n常用的置信水平及正态分布曲线下右侧面积为时的值（）\n  \n\n\n\n\n\n评价估计量的标准\n\n无偏性\n估计量抽样分布的数学期望等于被估计总体参数，, 则称为的无偏估计量\n\n\n有效性\n指用于估计同一个总体参数的两个无偏估计量，有更小标准差的估计量更有效\n\n\n一致性\n指随着样本量的增大，估计量的值越接近被估计的总体参数\n\n\n\n\n\n二、一个总体参数的区间估计\n总体均值的区间估计\n\n正态总体，方差已知 / 非正态总体，大样本\n\n样本均值的抽样分布均为正态分布，其数学期望为总体均值，方差为\n样本均值经过标准化后的随机变量服从标准正态分布，即\n总体均值在的置信水平下的置信区间为：\n 置信下限； 置信上限\n是事先确定的一个概率值/风险值，总体均值不包含在置信区间的概率\n称为置信水平\n标准正态分布曲线下右侧面积为时的值\n是估计总体均值时的误差\n总体均值的置信区间：点估计值+描述估计量精度的值/估计误差\n\n\n服从正态分布，方差未知，或总体不服从正态分布，但存在大样本\n总体方差可用样本方差代替，此时总体均值在置信水平下的置信区间：\n\n\n\n\n正态总体，方差未知，小样本\n\n样本方差代替，样本均值经过标准化后的随机变量服从自由度为的分布\n\n分布建立的总体均值在置信水平下的置信区间：\n是自由度为1时，分布右侧面积为时的值\n\n\n\n\n不同情况总体均值的区间估计\n  \n\n\n\n总体比例的区间估计\n\n大样本情况下总体比例的估计\n由样本比例的抽样分布\n当样本量足够大时，比例的抽样分布可用正态分布近似\n的数学期望; 方差为\n样本比例经过标准化后的随机变量服从标准正态分布\n在样本比例的基础上加减估计误差\n样本比例代替，总体比例的置信区间：\n\n\n\n\n\n\n总体方差的区间估计\n\n正态总体方差的估计\n由样本方差的抽样分布\n样本方差服从自由度为的分布\n建立总体方差的置信区间，即找到一个\\chi^2值，满足\n\n由，代替\n有\n\n\n总体方差\\sigma^2在1-\\alpha置信水平下的置信区间\n\n\n\n\n\n\n\n\n\n\n三、两个总体参数的区间估计\n两个总体均值之差的区间估计\n设两个总体均值分别为和，从两个总体中抽取样本量为和的两个随机样本\n样本均值分别为。两个总体均值之差\n两个总体均值之差的估计：独立样本\n两个总体都为正态分布或大样本\n两个样本均值之差服从期望值、方差\n两个样本均值之差经过标准化后服从标准正态分布\n\n\n\n方差已知时，两个总体均值之差在置信水平下的置信区间\n\n\n\n方差未知时\n\n\n\n\n\n两个总体均值之差的估计：匹配样本\n两个总体均值之差在在置信水平下的置信区间\n\n方差未知时\n\n\n\n\n\n\n\n\n\n\n\n两个总体比例之差的区间估计\n两个总体比例之差在置信水平下的置信区间\n\n\n\n\n\n两个总体方差之比的区间估计\n两个样本方差之比的抽样分布服从分布\n两个总体方差之比在置信水平下的置信区间\n≤≤ \n\n\n\n\n\n\n\n\n四、样本量的确定\n估计总体均值时\n估计误差, \n\n\n估计总体比例时\n估计误差, \n\n\n\n第八章 假设检验一、假设检验的基本问题\n假设问题的提出\n\n假设的表达式\n\n原假设，备择假设\n\n\n两类错误\n\n错误：弃真错误；错误：取伪错误\n\n\n假设检验的流程\n\n提出原假设和备择假设\n确定适当的检验统计量，并计算其数值\n参数的假设检验中，同参数估计，需要根据样本统计量进行推断，称为检验统计量\n总体已知且样本量大\n\n\n\n若|&lt;||，不拒绝，若|&gt;||，拒绝\n\n\n利用值进行决策\n\n值：原假设为真时样本观察结果出现更加极端结果的概率\n样本数据与原假设之间的差异\n样本量\n被假设参数的总体分布\n\n\n\n\n单侧检验\n\n双侧检验\n\n=3190g，3190g\n\n  \n  \n\n左单侧检验 / 下限检验\n\n：≥1000，：&lt;1000\n\n  \n  \n\n右单侧检验 / 上限检验\n\n：≤5%，：&gt;5%\n\n  \n\n\n\n\n二、一个总体参数的检验\n检验统计量的确定\n主要检验统计量：统计量，统计量，统计量\n统计量，统计量：均值和比例\n统计量：方差\n\n\n样本量\n样本量大（）\n总体服从正态分布，则样本统计量服从正态分布\n总体非正态分布，则样本统计量渐进服从正态分布\n\n\n总体标准差已知时\n\n\n\n总体标准差未知时\n\n\n\n\n\n总体标准差\n总体标准差已知，样本量小，样本统计量服从正态分布，统计量\n总体标准差未知，使用样本标准差，样本统计量服从分布，统计量\n, 自由度\n\n\n\n\n\n\n总体均值的检验\n总体比例的检验\n\n\n\n总体方差的检验\n, \n\n则拒绝原假设；\n\n\n\n\n\n三、两个总体参数的检验\n检验统计量的确定\n\n两个总体均值之差、比例之差、方差之比\n\n被检验参数的抽样分布（样本量大小、总体方差是否已知）\n\n  \n\n\n\n两个总体均值之差的检验\n\n和已知\n\n\n\n和未知，较小\n, ()\n\n, ()\n\n\n\n\n\n\n两个总体比例之差的检验\n\n两个总体服从二项分布，某特征比例未知，样本比例\n检验两个总体比例相等\n\n\n\n\n\n两个总体方差之比的检验\n\n正态总体条件下，两个方差之比服从分布\n\n分布双侧检验\n\n\n\n\n\n\n\n检验中的匹配样本\n\n\n第九章 分类数据分析一、分类数据与统计量\n分类数据\n分类数据的结果是频数，检验是对分类数据的频数进行分析的统计方法\n\n\n统计量\n用于测定两个分类变量之间的相关程度\n表示观察值频数，表示期望值频数，则统计量\n\n\n统计量的分布与自由度有关\n统计量描述了观察值与期望值的接近程度\n\n\n\n\n\n\n\n二、拟合优度检验\n拟合优度检验\n依据总体分布状况，计算出分类变量中各类别的期望频数，与分布的观察频数对比，判断期望频数与观察频数是否有显著差异\n\n\n\n三、列联分析：独立性检验\n列联表\n讲两个以上的变量进行交叉分类的频数分布表\n\n\n独立性检验\n\n自由度= \n\n\n\n\n\n\n四、列联表的相关测量\n相关系数\n\n描述2x2列联表数据相关程度: \n\n、相互独立时，\n  \n\n越大，变量、相关程度越高\n\n\n\n列联相关系数\n\n列联系数，系数，\n，两变量相互独立\n不同行列计算的列联系数不便比较\n\n\n\n\n相关系数\n\n\n，两变量相互独立\n\n\n\n\n数值分析\n\n不同列联表变量之间的相关程度比较时，行与行列与列个数相同，采用同一个系数\n\n\n\n五、列联分析\n问题\n条件百分表的方向\n列：为自变量\n\n\n分布的期望值准则\n每个单元期望值频数≥5\n\n\n\n\n\n第十章 分类数据分析一、方差分析引论\n方差分析\n通过检验各总体的均值是否相等来判断分类型自变量对数值型因变量是否有显著影响\n\n\n方差分析基本思想和原理\n图形描述\n散点图\n\n\n误差分解\n通过对数据误差来源的分析来判断不同总体均值是否相等\n总误差\n组内误差\n组间误差\n\n\n\n\n误差分析\n\n\n方差分析中的基本假定\n三个基本假定\n每个总体服从正态分布\n各个总体方差相同\n观测值独立\n\n\n\n\n\n二、单因素方差分析\n一个分类型自变量对一个数值型因变量的影响\n\n数据结构\n  \n\n分析步骤\n\n提出假设\n\n原假设：按照自变量取值分类，因变量均值相等。检验因素的个水平（总体）均值是否相等\n 自变量对因变量没有显著影响\n不完全相等       自变量对因变量有显著影响\n为第个总体均值\n\n\n\n\n构造检验的统计量\n\n计算各样本均值\n第个总体抽取个简单随机样本，第个总体样本均值为\n,  \n\n\n\n\n计算全部观测值的均值\n\n\n\n计算各误差平方和\n总平方和、组间平方和、组内平方和\n\n\n\n\n\n\n\n\n计算统计量\n均方：消除观测值对误差平方和的影响，用各平方和除以对应的自由度\nSST自由度n-1，n为观测值个数\nSSA自由度k-1，k为因素个体（总体）个数\nSSE自由度n-k\n\n\nMSA: 组间方差\n\n\n\nMSE: 组内方差\n\n\n\n为真,比值分布服从分子自由度，分母自由度的分布\n\n\n\n\n\n\n\n统计决策\n\n若原假设成立，表明没有系统误差，MSA/MSE比值不会太大\n若MSA&gt;MSE，说明各总体之间的差异不仅有随机误差，还有系统误差\n根据给定的显著性水平，在分布表查找临界值\n, 拒绝原假设，检验的因素对观测值有显著影响\n, 不拒绝原假设，不能认为检验的因素对观测值有显著影响\n\n\n\n\n方差分析表\n  \n\n\n\n关系强度的测量\n\n两个变量之间的关系强度\n\n表明自变量对因变量的影响效应占总效应的\n\n\n\n\n方差分析的多重比较\n\n最小显著差异方法\n提出假设：; \n计算检验统计量：\n计算\n为分布临界值，自由度为，MSE组内方差，和是第、个样本的样本量\n根据显著性水平作出决策\n如果，拒绝；，则不拒绝\n\n\n\n\n\n\n\n三、双因素方差分析\n双因素方差分析及其类型\n无重复双因素分析\n可重复双因素分析\n\n\n无交互作用的双因素方差分析\n数据结构\n  \n\n\n\n\n\n\n分析步骤\n\n提出假设\n\n行因素原假设：按照自变量取值分类，因变量均值相等。检验因素的个水平（总体）均值是否相等\n 自变量对因变量没有显著影响\n不完全相等       自变量对因变量有显著影响\n为第个总体均值\n\n\n列因素原假设：按照自变量取值分类，因变量均值相等。检验因素的个水平（总体）均值是否相等\n 自变量对因变量没有显著影响\n不完全相等       自变量对因变量有显著影响\n为第个总体均值\n\n\n\n\n构造检验统计量\n\n\n\n\n\n\n\n自由度\nSST\n=\n=\n=\n\n\n行因素统计量\n\n\n\n列因素统计量\n\n\n\n\n\n统计决策\n\n, 拒绝原假设，检验的行因素对观测值有显著影响\n, 拒绝原假设，检验的列因素对观测值有显著影响\n\n\n方差分析表\n  \n\n\n\n关系强度的测量\n\n两个自变量合起来与因变量之间的关系强度\n\n\n\n\n\n\n\n有交互作用的双因素方差分析\n方差分析表\n  \n\n平方和\n\n\n\n\n\n\n\n\n\n\n\n第十一章 一元线性回归一、变量间关系的度量\n变量间的关系\n相关关系的描述与测度\n散点图\n相关系数\n根据样本数据计算的度量两个变量之间线性关系强度的统计量\n总体相关系数：根据总体全部数据\n样本相关系数：根据样本数据\n线性相关系数、相关系数\n\n\n\n性质\n取值范围\n\n: 存在正线性相关; , 存在完全正线性相关\n: 存在负线性相关; , 存在完全负线性相关\n, 不存在线性相关\n\n\n对称性\n\n\n\n的大小与数据原点和计量尺度无关\n仅仅是线性关系的一个度量，不意味着一定有因果关系\n\n\n\n\n\n\n相关关系的显著性检验\n样本相关系数作为的近似估计值\n的抽样分布\n为较大的正值，左偏分布\n为较大的负值，右偏分布\n接近0，样本量很大时，接近正态分布\n\n\n的显著性检验\n提出假设\n\n\n\n计算检验统计量\n\n\n\n决策\n给定显著性水平和自由度\n, 拒绝原假设，存在显著线性关系\n\n\n\n\n\n\n\n\n\n二、一元线性回归\n一元线性回归模型\n回归模型\n描述因变量如何依赖于自变量和误差项的方程\n因变量：被预测或被解释变量\n自变量：用来预测或解释因变量的一个或多个变量\n\n\n一元回归：回归中只涉及一个自变量\n因变量y与自变量x为线性关系，则为一元线性回归\n只涉及一个自变量的一元线性回归模型\n因变量y与自变量x具有线性关系\n重复抽样，自变量x取值固定，x非随机\n, , \n\n\n\n\n回归方程\n描述因变量的期望值如何依赖于自变量的方程\n\n\n估计的回归方程\n用样本统计量和代替回归方程中未知参数和\n\n\n\n\n\n参数的最小二乘估计\n\n\n\n\n\n\n\n\n\n\n回归直线的拟合优度\n回归直线与各观测点的接近程度称为回归直线对数据的拟合优度\n判定系数\n对估计的回归方程拟合优度的度量\n因变量变差的平方和\n\n: 各实际观测点与回归值的残差平方和\n: 回归值与均值的离差平方和\n\n\n判定系数\n相关系数是判定系数\n估计标准误差\n度量各实际观测点在直线周围散布状况的一个统计量，均方残差的平方根\n\n\n\n\n\n\n\n显著性检验\n对于，如果原假设成立（, 两个变量之间线性关系不显著）\n\n检验\n提出假设, 两个变量之间线性关系不显著\n计算检验统计量\n\n\n\n\n回归系数的检验\n服从正态分布\n数学期望, 标准差\n是误差项的标准差，估计量\n\n\n\n构造检验回归系数的统计量\n提出检验\n计算统计量\n决策：给定显著性水平，自由度，, 拒绝\n\n\n\n\n\n\n回归分析结果评价\n\n三、利用回归方程进行预测\n点估计\n平均值、个别值点估计\n利用估计的回归方程，对于的一个特定值，求出平均值的一个估计值\n\n\n\n\n区间估计\n利用估计的回归方程，对于的一个特定值，求出一个估计值的区间\n置信区间估计：平均值的估计区间\n预测区间估计：个别值的区间估计\n\n\n平均值的置信区间估计\n表示标准差的估计量\n\n给定, 在置信水平下的置信区间为\n\n\n\n\n\n个别值的预测区间估计\n\n\n\n\n\n\n四、残差分析\n残差与残差图\n残差\n: 因变量观测值与估计回归方程的预测值\n\n\n残差图\n残差图、残差图、标准化残差图\n\n\n\n\n标准化残差\n标准化残差：残差除以其标准差，对正态性假定的检验\n\n误差项服从正态分布，标准化残差也应该服从正态分布\n\n\n\n\n\n第十二章 多元线性回归一、多元线性回归模型\n多元线性回归模型与回归方程\n多元线性回归模型\n\n因变量，个自变量, 误差项\n\n\n多元回归方程: \n\n\n估计的多元回归方程\n\n偏回归系数: \n\n\n\n\n参数的最小二乘估计\n\n\n\n\n\n\n\n\n\n二、回归方程的拟合优度\n多重判定系数\n度量多元回归方程拟合程度的一个统计量，回归平方和占总平方和的比例\n\n\n\n\n\n\n调整的多重判定系数\n\n平方根称为多重相关系数，复相关系数\n\n\n\n\n估计标准误差\n\n\n\n\n三、显著性检验\n线性关系检验\n检验因变量与个自变量之间的关系是否显著，总体显著性检验\n提出假设\n\n至少有一个不为0\n\n\n计算检验统计量\n决策：给定显著性水平，分子自由度，分母自由度，\n, 拒绝原假设 / \n, 不拒绝原假设 / \n\n\n\n\n\n\n回归系数检验和推断\n提出假设\n对, \n\n\n计算检验统计量\n\n\n\n\n决策\n给定显著性水平\\alpha，自由度n-k-1\n, 拒绝原假设\n, 不拒绝原假设\n\n\n\n\n\n四、多重共线性\n回归模型中两个或两个以上自变量彼此相关\n判别\n计算模型中各对自变量相关系数，并进行显著性检验\n模型中各对自变量显著相关\n模型线性关系检验（检验）显著时，几乎所有回归系数的检验不显著\n回归系数正负号与预期相反\n容忍度越小，方差扩大因子VIF越大\n\n\n\n\n处理\n将一个或多个相关的自变量从模型中剔除\n保留\n避免统计量对单个参数进行检验\n对因变量y值的推断限定在自变量样本范围之内\n\n\n\n\n\n五、利用回归方程进行预测六、变量选择与逐步回归\n变量选择过程\n选择自变量通常是对统计量进行显著性检验：将一个或一个以上自变量引入回归模型，是否使残差平方和SSE显著减少\n向前选择\n模型中没有自变量\n对k个自变量分别拟合因变量的一元线性回归模型，找出F统计量值最大的模型及自变量，引入模型\n在此基础上，分别拟合和其它个自变量的线性回归模型，找出F统计量值最大的模型及自变量，引入模型\n不断向模型中增加自变量直至不能导致SSE显著增加\n\n\n向后剔除\n对因变量拟合包括所有k个自变量的线性回归模型，考察p(p&lt;k)个去掉一个自变量的模型（每个模型均含k-1个自变量），使模型SSE减少最小的自变量剔除\n考察p-1个去掉一个自变量的模型（每个模型均含k-2个自变量），使模型SSE减少最小的自变量剔除\n直至剔除一个自变量不能使SSE显著减小为止\n\n\n逐步回归\n结合向前选择和向后剔除\n增加一个自变量\n考察所有自变量\n\n\n\n\n\n\n\n第十三章 时间序列分析和预测一、时间序列及其分解\n时间序列\n是同一现象在不同时间的相继观察值排列而成的序列\n平稳序列\n基本上不存在趋势的序列，各观察值基本上在某个固定的水平上波动，在不同时间段波动程度不同，但不存在某种规律，波动随机\n\n\n非平稳序列\n包含趋势、季节性或周期性的序列，可能含一种或多种成分\n\n\n趋势\n时间序列在长期内呈现出来的某种持续上升或持续下降的变动，线性或非线性\n\n\n季节性S\n季节变动，时间序列在一年内重复出现的周期性波动，含有或不含有趋势\n\n\n周期性\n循环波动，时间序列中呈现出来的围绕长期趋势的一种波浪形或振荡式变动\n\n\n除去以上的波动性称为随机性\n不规则波动\n\n\n\n\n按照对时间序列的影响方式不同，时间序列可分解为\n加法模型\n乘法模型\n\n\n\n\n\n二、时间序列的描述性分析\n图形描述\n折线图\n\n\n增长率分析\n增长率\n增长速度，时间序列中报告期观察值与基期观察值之比-1\n对比基期的不同\n环比增长率\n\n报告期观察值与前一时期观察值之比-1\n说明现象逐期增长变化程度\n\n\n定基增长率\n\n报告期观察值与某一固定时期观察值之比-1\n说明现象在整个观察期内总的增长变化程度\n\n\n\n\n\n\n平均增长率\n平均增长速度，时间序列中逐期环比值（环比发展速度）的几何平均数-1\n\n环比值个数\n\n\n\n\n\n三、预测方法的选择\n选择预测方法\n  \n\n预测方法评估\n\n平均误差\n时间序列第个观察值, 预测值, 所有预测误差平均数为平均误差\n\n\n\n平均绝对误差\n预测误差取绝对值计算的平均误差\n\n\n\n均方误差\n\n\n\n平均百分比误差和平均绝对百分比误差\nMA、MAD、MSE受时间序列数据水平和计量单位的影响\n平均百分比误差\n平均绝对百分比误差\n\n\n\n\n\n四、平稳序列的预测\n简单平均法\n根据已有的t期观察值通过简单平均来预测下一期数值\n\n\n\n\n\n\n\n移动平均法\n对时间序列逐期递移求得平均数\n简单移动平均法\n最近的期数据平均，移动间隔为\n\n\n\n加权移动平均法\n\n\n指数平滑法\n通过对过去的观察值加权平均进行预测\n使t+1期预测值=t期实际观察值与预测值的加权平均值\n是加权平均的一种特殊形式，观察值越久远，其权数呈指数下降\n一次、二次、三次指数平滑\n\n\n一次指数平滑/单一指数平滑法\n\n为平滑系数\n\n\n\n\n\n五、趋势型序列的预测\n线性趋势预测\n线性趋势\n现象随着时间的推移呈现出稳定增长或下降的线性变化规律\n\n最小二乘法\n趋势估计的误差用线性回归的估计标准误差\n\nm为趋势方程中待确定的未知数个数\n\n\n\n\n非线性趋势\n指数曲线\n以几何级数递增或递减的现象，即时间序列观察值按指数规律变化\n\n取对数\n\n取、反对数\n\n\n多阶曲线\n阶曲线函数: \n\n\n\n\n\n\n复合型序列的分解预测\n分解模型\n分解法\n确定并分解季节成分\n用序列的每一个观察值除以相应的季节指数\n\n\n建立预测模型\n线性：一元线性回归模型\n非线性\n\n\n计算预测值\n\n\n\n\n\n第十三章 指数一、基本问题\n指数概念\n统计指数，测定多项内容数量综合变动的相对数\n实质是测定多项内容\n表现形式为动态相对数\n\n\n\n\n指数分类\n考察对象的范围\n个体指数：反映总体中个别现象和个别项目数量变动的相对数，是计算总指数的基础\n总指数：反映多种项目数量变动的相对数\n\n\n反映指标的性质\n数量指标指数：反映数量指标变动程度的相对数\n质量指标指数：反映品质指标变动程度的相对数\n\n\n计算形式\n简单指数：计入指数的各个项目重要性视为相同\n加权指数：对计入指数的各个项目依据重要程度赋予不同的权数\n\n\n\n\n指数编制中的问题\n选择项目\n确定权数\n指数计算方法\n\n\n\n二、总指数编制方法\n简单指数\n简单综合指数\n报告期的指标总和与基期的指标总和相对比的指数\n\n\n简单平均指数\n个体指数进行简单平均得到的总指数\n\n\n\n\n加权指数\n加权综合指数\n加权平均指数\n以个体指数为基础，通过对个体指数进行加权平均编制的指数\n\n\n\n\n\n三、指数体系\n总量指数体系分析\n总量指数体系\n一个总量往往可以分解为若干个构成因素，其数量关系可以用指标体系的形式表现出来\n\n\n\n\n平均数变动因素分解\n\n四、经典指数\n经典指数\n居民消费价格指数\n股票价格指数\n消费者满意度指数\n\n\n\n五、综合评价指数\n综合评价和综合评价指数\n综合评价指数构造方法\n统计标准化\n相对标准化\n功效系数法\n\n\n\n","categories":["Note"],"tags":["Stat"]}]